<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>吴恩达机器学习二</title>
      <link href="2020/12/29/wu-en-da-ji-qi-xue-xi-er/"/>
      <url>2020/12/29/wu-en-da-ji-qi-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习二"><a href="#吴恩达机器学习二" class="headerlink" title="吴恩达机器学习二"></a>吴恩达机器学习二</h1><blockquote><p>本章主要讲解的是利用逻辑回归求解分类问题，介绍了假设函数、决策边界、代价函数、梯度下降函数基本求解方法，随后介绍了使用更高级的优化策略来求解问题，并由二元分类推广至多元分类。然后引出了欠拟合和过拟合的问题，并引入了正则化的思想来解决该问题。</p></blockquote><h2 id="一、逻辑回归"><a href="#一、逻辑回归" class="headerlink" title="一、逻辑回归"></a>一、逻辑回归</h2><h3 id="1、分类问题"><a href="#1、分类问题" class="headerlink" title="1、分类问题"></a>1、分类问题</h3><p>分类问题中，对于给定输入 $x$，待预测的 $y$ 为离散值，在最简单的二元分类中  $y$ 的值仅取 1 或 0，通常称 $y=1$ 为正类，$y=0$ 为负类。例如给定肿瘤的大小、肿瘤发展的时间（向量 $x$），来判断肿瘤是否为恶性肿瘤（因变量 $y\in\{0,1\}$）。</p><p>如果使用线性回归算法的话，会带来两个问题：</p><ol><li>无法相对清晰的界定 $y$ 取不同值时 $x$ 所属的范围。</li><li>其输出值可能会远远超过 0 或 1，而我们仅仅需要预测 $y$ 为 0 或为 1.</li></ol><p>因此，我们采用逻辑回归算法（logistic regression）来求解分类问题。</p><h3 id="2、假设函数（Hypothesis-Representation）"><a href="#2、假设函数（Hypothesis-Representation）" class="headerlink" title="2、假设函数（Hypothesis Representation）"></a>2、假设函数（Hypothesis Representation）</h3><p>在线性回归中，我们的假设函数为（$x$ 和 $\theta$ 均为向量）：</p><script type="math/tex; mode=display">h_\theta(x)=x^T\theta</script><p>而逻辑回归中，我们的假设函数为：</p><script type="math/tex; mode=display">\begin{cases}h_\theta(x)=g(x^T\theta)\\g(t)=\frac{1}{1+e^{-t}}\end{cases}\Rightarrow h_\theta(x)=\frac{1}{1+e^{-x^T\theta}}</script><p>其中 $g(t)$ 为逻辑方程（logistic function），这也是逻辑回归名称的由来。其中 $g(x)$ 的图像如下所示：</p><p><img src="/2020/12/29/wu-en-da-ji-qi-xue-xi-er/Users\JiangChenyang\AppData\Roaming\Typora\typora-user-images\image-20201228212739223.png" alt="逻辑函数图像" style="zoom: 33%;"></p><p>当 $h(x)\geq0.5$ 时，我们预测 $y=1$；当 $h(x)&lt;0.5$ 时，我们预测 $y=0$。其中 $h(x)$ 其实为 $y=1$ 的概率。有以下两组公式</p><script type="math/tex; mode=display">P(y=1|x,\theta)=h(x)\\P(y=0|x,\theta)=1-h(x)</script><p> 其表示在自变量 $x$ 以及参数为 $\theta$ 的条件下，$y=1$ 以及 $y=0$ 的概率。若我们通过数据集 ${X,y}$ 得到了优化后的参数 $\theta$ ，那么我们就可以写出假设函数 $h(x)$，进而输入 $x$ 来预测输出 $y$ 为 0 或者 $y$ 为 1 的概率。</p><h3 id="3、决策边界"><a href="#3、决策边界" class="headerlink" title="3、决策边界"></a>3、决策边界</h3><p>由假设函数可知</p><script type="math/tex; mode=display">y=1\Rightarrow h(x)\geq0.5\Rightarrow x^T\theta\geq0\\y=0\Rightarrow h(x)<0.5\Rightarrow x^T\theta<0</script><p>我们可以发现 $x^T\theta=0$ 定义了 $y=1$ 与 $y=0$ 的边界。例如 $x^T={1,x_1,x_2}$，我们输入训练数据之后得到 $\theta^T={\theta_0,\theta_1,\theta_2}$，那么由 $\theta_0+\theta_1x_1+\theta_2x_2=0$ 所决定的直线就定义了预测 $y=1$ 与 $y=0$ 的边界，我们称此边界为 <strong>决策边界</strong>。</p><p><img src="/2020/12/29/wu-en-da-ji-qi-xue-xi-er/Users\JiangChenyang\AppData\Roaming\Typora\typora-user-images\image-20201228223857481.png" alt="决策边界实例" style="zoom: 33%;"></p><p>对于更复杂的决策边界，我们可以这样定义假设函数：</p><script type="math/tex; mode=display">h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1^2+\theta_4x_2^2)\\h_\theta(x)=g(\sum_{k_1,k_2,\cdots,k_n}a_{k_1k_2\cdots k_n}x_1^{k_1}x_2^{k_2}\cdots x_n^{k_n})</script><p>从而得到更加复杂的边界曲线。</p><h3 id="4、代价函数"><a href="#4、代价函数" class="headerlink" title="4、代价函数"></a>4、代价函数</h3><p>我们需要根据代价函数来判断所选参数 $\theta$ 的优劣，并进一步通过梯度函数来优化参数 $\theta$ 。考虑在线性回归中选用的代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2</script><p>线性回归中，我们利用了其代价函数为凸函数的性质，进一步使用梯度下降法，得到梯度下降方程，从而可以不断地优化 $\theta$。而在分类问题中，若仍沿用线性回归中代价函数的处理办法，即定义</p><script type="math/tex; mode=display">J(\theta)_{logistic}=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2\\</script><p>即</p><script type="math/tex; mode=display">J(\theta)_{logistic}=\frac{1}{2m}\sum_{i=1}^m(g(x^T\theta))-y^{(i)})^2</script><p>那么我们得到的代价函数为非凸函数（non-convex function），无法应用梯度下降法。故重新定义梯度下降函数</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^mCost(h_\theta(x^{(i)}),y^{(i)})\\</script><p>其中</p><script type="math/tex; mode=display">Cost(h_\theta(x), y)=\begin{cases}-log(h_\theta(x))\quad &y=1\\-log(1-h_\theta(x))\quad &y=0\end{cases}</script><p>这样可以保证代价函数为凸函数，从而进一步应用梯度下降法。</p><h3 id="5、梯度下降法"><a href="#5、梯度下降法" class="headerlink" title="5、梯度下降法"></a>5、梯度下降法</h3><p>在应用梯度下降法之前，我们需要先将代价函数进行简化</p><script type="math/tex; mode=display">\begin{aligned}Cost(h_\theta(x),y)=&\begin{cases}-log(h_\theta(x))\quad &y=1\\-log(1-h_\theta(x))\quad &y=0\end{cases}\\&\Downarrow\\Cost(h_\theta(x),y)=&-(ylog(h\theta(x))+(1-y)log(1-h_\theta(x)))\end{aligned}</script><p>从而得到代价函数：</p><script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}\sum_{i=1}^m(ylog(h\theta(x))+(1-y)log(1-h_\theta(x)))</script><p>应用梯度下降方程并对 $J(\theta)$ 求导可得</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script><p><del>由于某种巧合</del>，可以发现该梯度下降方程和线性回归的梯度下降方程一样，但值得注意的是，两者的 $h_\theta(x)$ 函数并不相同。</p><h3 id="6、高级优化"><a href="#6、高级优化" class="headerlink" title="6、高级优化"></a>6、高级优化</h3><p>相较于上文的梯度下降方法，其实有更高级快速的方法可供选择。如 共轭梯度法（Conjugate descent）​、局部优化法（BFGS）、有限内存局部优化法（L-BFGS）。实现较为困难，可以直接掉包。（没错，我就是调包侠）</p><h3 id="7、多元分类问题"><a href="#7、多元分类问题" class="headerlink" title="7、多元分类问题"></a>7、多元分类问题</h3><p>有时我们会遇到因变量 $y$ 可以取不止两个值的情况，比如邮件分类可以分为垃圾邮件、家人邮件、公司邮件等，这时就需要对二元分类问题进行推广。</p><p><img src="/2020/12/29/wu-en-da-ji-qi-xue-xi-er/Users\JiangChenyang\AppData\Roaming\Typora\typora-user-images\image-20201228234831484.png" alt="image-20201228234831484" style="zoom:33%;"></p><p>我们采用 One-vs-All 的思路来解决多元问题。令 $y=i$ 为正类，$y\neq i$ 为负类，那么我们可以得到关于 $y=i$ 的假设函数，有</p><script type="math/tex; mode=display">P(y=i|x,\theta)=h_\theta^{(i)}(x)</script><p>由此，对于 $n$ 元分类问题，我们可以得到 $n$ 个类似的假设函数，并通过数据集优化，得到这 $n$ 个假设函数各自的 $\theta$ 参数。我们称 $h_\theta^{(i)}$ 为 1 个分类机，可以得到 $n$ 个分类机。当我们进行预测时，我们将 $x$ 输入 $n$ 个分类机中，即通过 $h_\theta^{(i)}(x)$ 得到 $y=i$ 的概率，最后选择概率最大的 $i$ 输出即可。</p><p><img src="/2020/12/29/wu-en-da-ji-qi-xue-xi-er/Users\JiangChenyang\AppData\Roaming\Typora\typora-user-images\image-20201229000909220.png" alt="image-20201229000909220" style="zoom:33%;"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达机器学习一</title>
      <link href="2020/12/27/wu-en-da-ji-qi-xue-xi-yi/"/>
      <url>2020/12/27/wu-en-da-ji-qi-xue-xi-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习（一）"><a href="#吴恩达机器学习（一）" class="headerlink" title="吴恩达机器学习（一）"></a>吴恩达机器学习（一）</h1><blockquote><p>主要总结了一下机器学习的基本知识，单变量线性回归的基本概念以及基本解法。</p></blockquote><h2 id="一、机器学习概括"><a href="#一、机器学习概括" class="headerlink" title="一、机器学习概括"></a>一、机器学习概括</h2><blockquote><p>定义：A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.——Tom Mitchell</p></blockquote><p>直白地来说，机器学习是一个被用来完成任务 $T$ 的程序，其可以通过在经验 $E$ 中学习，提高其任务完成的表现度 $P$。</p><ul><li><p>监管学习（supervised learning)</p><p>  有时候，我们希望通过给定程序特定的输入来进行预测。比如输入人口数目从而得到某一地区的销售额。<strong>监管学习</strong>是指首先给定程序已知的数据，随后期待给定未知的输入从而预测结果。比如首先给定已知的北京市人口与销售额的关系、上海市人口与销售额的关系等等，随后输入深圳市的人口，期待得到一个销售额的预测值。</p><p>  监管学习主要有<strong>回归分析</strong>（Regression）和<strong>分类分析</strong>（Classification）</p></li><li><p>无监管学习（unsupervised learning）</p><p>  有时候我们的数据没有标签，我们需要机器自动进行分类。比如一段声音中既有人声也有汽车声，采用无监管学习可以将人声和汽车声进行区分。</p></li></ul><h2 id="二、单变量线性回归基本概念"><a href="#二、单变量线性回归基本概念" class="headerlink" title="二、单变量线性回归基本概念"></a>二、单变量线性回归基本概念</h2><p>单变量线性回归属于监管学习。</p><p>给定一组数据，我们需要对该组数据进行线性拟合。如下图中，给定“人口-利润”的输入，随后我们找到一条直线，使得其尽可能反映数据集中“人口-利润”的线性关系。为此，首先需要定义函数：</p><p><img src="/2020/12/27/wu-en-da-ji-qi-xue-xi-yi/download.png" alt="人口-利润"></p><ul><li><p>假设函数（Hypothesis）</p><script type="math/tex; mode=display">  h_\theta=\theta_0+\theta_1x</script></li><li><p>参数（parameters）</p><script type="math/tex; mode=display">  \theta_0,\theta_1</script></li><li><p>代价函数（Cost Function）</p><script type="math/tex; mode=display">  J(\theta_0,\theta_1)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x_i)-y_i)^2</script></li></ul><p>我们的目标是得到使得代价函数 $J(\theta_0,\theta_1)$ 尽可能小的参数 $\theta_0,\theta_1$。</p><h2 id="三、单变量线性回归解决方法——梯度下降法"><a href="#三、单变量线性回归解决方法——梯度下降法" class="headerlink" title="三、单变量线性回归解决方法——梯度下降法"></a>三、单变量线性回归解决方法——梯度下降法</h2><p>我们通常采用梯度下降法（Gradient Descent）来解决线性回归问题。主要思路是，首先设置 $\theta_0,\theta_1$ 的初始值，随后不断改变 $\theta_0,\theta_1$，使得代价函数不断减小，直至收敛。我们采用下面的方程更新参数：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)\quad j\in\{0,1\}（1）</script><p>通过该方程，我们可以不断地逼近代价函数的极小值点，由于线性代价函数的极值点仅有一个，故其为最小值点，从而可以得到问题的解。其中 $\alpha$ 为逼近速率，当 $\alpha$ 过大时可能会造成不收敛的情况。</p><p>化简$（1）$式可得</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x_i)-y_i)x_j\quad j\in{0,1}</script><p>借助该式可以求解问题。</p><h2 id="四、多变量线性回归"><a href="#四、多变量线性回归" class="headerlink" title="四、多变量线性回归"></a>四、多变量线性回归</h2><p>训练数据包含多个特征值时需要用到多变量线性回归相关知识。比如房价会受到房子大小、房子卧室数目等因素的影响，则特征值包括房子大小、房子卧室等。给定多组训练数据，每组训练数据以 $\{x_1,x_2,…,x_n,y\}$ 的形式呈现。记 $X=(x_0,x_1,x_2,…,x_n)$，其中 $x_0\equiv1$，用来表征特征值。记 $\theta=(\theta_0,\theta_1,…,\theta_n)$ 用来表示参数。</p><p>多变量线性回归问题的假设函数为：</p><script type="math/tex; mode=display">h(x_1,x_2,...,x_n)=\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_n+x_n</script><p>用向量形式表示即为：</p><script type="math/tex; mode=display">h(X)=X\cdot\theta^T</script><p>进而可以得到代价方程和梯度下降方程：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h(X^{(i)})-y^{(i)})^2\\\theta_j=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m(h(X^{(i)})-y^{(i)})*X^{(i)}_j</script><p>其中 $X^{(i)}$ 表示第 $i$ 组测试数据的特征值向量，$X^{(i)}_j$ 表示第 $i$ 组测试数据的第 $j$ 个特征值，$y^{(i)}$ 表示第 $i$ 组测试数据的期望值。</p><h2 id="五、特征缩放"><a href="#五、特征缩放" class="headerlink" title="五、特征缩放"></a>五、特征缩放</h2><p>对于多变量线性回归，如果其特征值的大小相差较大，可能会出现迭代次数较多甚至不收敛的情况，这是就需要将数据放缩至同样的规模大小，放缩方法如下：</p><script type="math/tex; mode=display">X_j=\frac{X_j-Mean(X_j)}{Std(X_j)}</script><p>其中 $X_j$ 所有测试数据中第 $j$ 个特征值组成的向量，$Mean（）$ 表示求均值，$Std（）$ 表示求标准差。</p><h2 id="六、梯度下降图像方面的问题"><a href="#六、梯度下降图像方面的问题" class="headerlink" title="六、梯度下降图像方面的问题"></a>六、梯度下降图像方面的问题</h2><p>通常建议绘制“代价—迭代次数”图像，可以更方便的调试程序和优化程序。当代价并不随迭代次数的增加而减小时，通常情况下是因为选择的 $\alpha$ 过大，此时减小 $\alpha$ 即可。但同时 $\alpha$ 过小时也可能造成收敛较慢的问题，此时就需要根据图像选择较优的 $\alpha$</p><p>以下为作业题中“代价—迭代次数”图像的实例：</p><ul><li><p>当 $\alpha=1.315$ 时（不收敛）</p><p>  <img src="/2020/12/27/wu-en-da-ji-qi-xue-xi-yi/image-20201226174543644.png" alt="α=1.315" style="zoom: 33%;"></p></li><li><p>当 $\alpha=1$ 时（收敛较快）</p><p>  <img src="/2020/12/27/wu-en-da-ji-qi-xue-xi-yi/image-20201226174709353.png" alt="α=1" style="zoom:33%;"></p></li><li><p>当 $\alpha=0.001$ 时（收敛较慢）</p><p>  <img src="/2020/12/27/wu-en-da-ji-qi-xue-xi-yi/image-20201226174819646.png" alt="α=0.001" style="zoom:33%;"></p></li></ul><h2 id="七、使用正规方程求解"><a href="#七、使用正规方程求解" class="headerlink" title="七、使用正规方程求解"></a>七、使用正规方程求解</h2><p>对于形如</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h(X^{(i)})-y^{(i)})^2</script><p>的<strong>多元线性回归问题</strong>，存在使得 $J(\theta)’=0$ 的通解：</p><script type="math/tex; mode=display">\theta=(X^TX)^{-1}X^Ty</script><p>使用该方程可以直接求出最优拟合直线的参数。但是由于矩阵求逆的算法时间复杂度是 $O(n^3)$ 的，因此若数据组数较多时，该算法占用时间较大，仍需要使用迭代算法求解。</p><p><strong>通解求解过程</strong>：</p><script type="math/tex; mode=display">\begin{aligned}J(\theta)&=\frac{1}{2}(X\theta-y)^T(X\theta-y)\\&=\frac{1}{2}(\theta^TX^TX\theta-y^TX\theta-\theta^TX^Ty+y^Ty)\\\end{aligned}</script><p>根据矩阵求导法则有：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial\theta^TX^TX\theta}{\partial\theta}&=2X^TX\theta\\\frac{\partial y^TX\theta}{\partial\theta}&=X^Ty\\\frac{\partial\theta^TX^Ty}{\partial\theta}&=X^Ty\end{aligned}</script><p>因此有：</p><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial\theta}=X^TX\theta-X^Ty</script><p>令导数等于零得：</p><script type="math/tex; mode=display">\begin{aligned}X^TX\theta-X^Ty&=0\\\theta&=(X^TX)^{-1}X^Ty\end{aligned}</script><p><del>矩阵求导法则有点多，我也没有搞太明白，就不在这里写了，以后可能会有补充 QAQ</del></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy数组学习</title>
      <link href="2020/12/24/numpy-shu-zu-xue-xi/"/>
      <url>2020/12/24/numpy-shu-zu-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy-数组学习"><a href="#numpy-数组学习" class="headerlink" title="numpy 数组学习"></a>numpy 数组学习</h1><p>2020.12.24 library jcy</p><p>这一部分主要包括 numpy 中关于数组的结构、定义以及相关操作</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h2><h2 id="1、创建一维序列"><a href="#1、创建一维序列" class="headerlink" title="1、创建一维序列"></a>1、创建一维序列</h2><p>可以将一维序列理解为数学中的向量</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 创建全 0 的序列</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment"># 创建全 1 的序列</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment"># 创建随机序列</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token comment"># 创建从 1-5 的序列</span>d <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token comment"># 创建 5 个等间距的样本</span>e <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token comment"># 创建自定义的序列</span>f <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[0. 0. 0. 0. 0.][1. 1. 1. 1. 1.][0.38560477 0.43756133 0.25563547 0.15480578 0.90388205][0 1 2 3 4][10.  12.5 15.  17.5 20. ][7 8 7 7 7]</code></pre><h2 id="二、创建二维数组"><a href="#二、创建二维数组" class="headerlink" title="二、创建二维数组"></a>二、创建二维数组</h2><p>可以将二维数组或更高维的数组理解为矩阵</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 创建一个 2*3 的全 0 矩阵</span>zero_2d_array <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'zero:\n'</span><span class="token punctuation">,</span> zero_2d_array<span class="token punctuation">)</span><span class="token comment"># 创建一个 2*3 的全 1 矩阵</span>one_2d_array <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'one:\n'</span><span class="token punctuation">,</span> one_2d_array<span class="token punctuation">)</span><span class="token comment"># 创建一个自定义矩阵</span>my_array <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'my:\n'</span><span class="token punctuation">,</span> my_array<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>zero: [[0. 0. 0.] [0. 0. 0.]]one: [[1. 1. 1.] [1. 1. 1.]]my: [[1 2] [3 4]]</code></pre><h2 id="三、多维数组的相关操作"><a href="#三、多维数组的相关操作" class="headerlink" title="三、多维数组的相关操作"></a>三、多维数组的相关操作</h2><h3 id="1、对多维数组进行切片"><a href="#1、对多维数组进行切片" class="headerlink" title="1、对多维数组进行切片"></a>1、对多维数组进行切片</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>6[[ 6  7] [10 11]][ 2  6 10 14][[ 1  3] [ 9 11]]</code></pre><h3 id="2、数组的属性"><a href="#2、数组的属性" class="headerlink" title="2、数组的属性"></a>2、数组的属性</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 类型名称</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>  <span class="token comment"># 内部的数据类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span>   <span class="token comment"># 数据数目</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># 数组的形状</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>itemsize<span class="token punctuation">)</span>   <span class="token comment"># 每一项占用的字节数</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>   <span class="token comment"># 数组的维度</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>nbytes<span class="token punctuation">)</span> <span class="token comment"># 数组中数据占用的字节数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&lt;class &#39;numpy.ndarray&#39;&gt;int3216(4, 4)4264</code></pre><h2 id="四、使用数组进行运算"><a href="#四、使用数组进行运算" class="headerlink" title="四、使用数组进行运算"></a>四、使用数组进行运算</h2><h3 id="1、基本操作符"><a href="#1、基本操作符" class="headerlink" title="1、基本操作符"></a>1、基本操作符</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>a <span class="token operator">=</span> a<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">79</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span>              <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">92</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> b<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11] [12 13 14 15]][[10 62  1 14] [ 2 56 79  2] [ 1 45  4 92] [ 5 55 63 43]]</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 下方的 +、-、*、/、**、&lt;、> 都是对数组进行逐位运算</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span><span class="token comment"># 计算两个数组的点积</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[[ 10  63   3  17] [  6  61  85   9] [  9  54  14 103] [ 17  68  77  58]][[-10 -61   1 -11] [  2 -51 -73   5] [  7 -36   6 -81] [  7 -42 -49 -28]][[   0   62    2   42] [   8  280  474   14] [   8  405   40 1012] [  60  715  882  645]][[0.         0.01612903 2.         0.21428571] [2.         0.08928571 0.07594937 3.5       ] [8.         0.2        2.5        0.11956522] [2.4        0.23636364 0.22222222 0.34883721]][[  0   1   4   9] [ 16  25  36  49] [ 64  81 100 121] [144 169 196 225]][[ True  True False  True] [False  True  True False] [False  True False  True] [False  True  True  True]][[False False  True False] [ True False False  True] [ True False  True False] [ True False False False]][[  19  311  276  315] [  91 1183  864  919] [ 163 2055 1452 1523] [ 235 2927 2040 2127]]</code></pre><h3 id="2、特殊运算符"><a href="#2、特殊运算符" class="headerlink" title="2、特殊运算符"></a>2、特殊运算符</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>4509[ 0  1  3  6 10 15 21 28 36 45]</code></pre><h2 id="五、进阶索引方式"><a href="#五、进阶索引方式" class="headerlink" title="五、进阶索引方式"></a>五、进阶索引方式</h2><h3 id="1、花式索引"><a href="#1、花式索引" class="headerlink" title="1、花式索引"></a>1、花式索引</h3><p>花式索引可以通过给定的序列列表得到对应位置的元素，进而得到一个新的序列。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># fancy indexing</span><span class="token comment"># 给定一个索引列表得到对应的序列</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>indices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>indices<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[ 0 10 20 30 40 50 60 70 80 90][10 40 90]</code></pre><h3 id="2、bool-屏蔽"><a href="#2、bool-屏蔽" class="headerlink" title="2、bool 屏蔽"></a>2、bool 屏蔽</h3><p>bool 屏蔽可以通过一个 bool 型数组访问序列中的特定元素</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Bool Masking</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plta <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment"># 得到函数图像</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token comment"># b >=0 返回一个 bool 型数组</span>mask <span class="token operator">=</span> b <span class="token operator">>=</span> <span class="token number">0</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>a<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'bo'</span><span class="token punctuation">)</span>mask <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;=</span> np<span class="token punctuation">.</span>pi <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>a<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'go'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/12/24/numpy-shu-zu-xue-xi/output_20_0.svg" alt="svg"></p><h3 id="3、where-函数"><a href="#3、where-函数" class="headerlink" title="3、where 函数"></a>3、where 函数</h3><p>where 函数用于得到满足指定条件的序列的下标。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>a <span class="token operator">>=</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">>=</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>(array([0, 1, 2, 3, 4], dtype=int64),)[5 6 7 8 9][False False False False False  True  True  True  True  True]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 重温</title>
      <link href="2020/12/23/python-chong-wen/"/>
      <url>2020/12/23/python-chong-wen/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-重温"><a href="#Python-重温" class="headerlink" title="Python 重温"></a>Python 重温</h1><blockquote><p>高三暑假学习的 python，现在已经忘完了。由于机器学习和数学建模的需要，现在需要重拾一下 python 的相关知识，在这里粗略的总结一下其与 C 的不同之处以及基本语法。</p></blockquote><h2 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h2><ul><li>python 保留字</li></ul><div class="table-container"><table><thead><tr><th>python</th><th>保留</th><th>字符</th></tr></thead><tbody><tr><td>and</td><td>exec</td><td>not</td></tr><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table></div><ul><li>python 采用强制缩进，且缩进格式必须相同</li><li>可以使用 <code>\</code> 将一条语句分为多行</li><li>注释可以使用 <code>&quot;#&quot;</code> 或 <code>&#39;&#39;&#39;</code></li><li>使用 <code>;</code> 可以在一行显示多条语句</li></ul><h2 id="Python-变量类型"><a href="#Python-变量类型" class="headerlink" title="Python 变量类型"></a>Python 变量类型</h2><p>python 中有五种标准的变量类型分别为：数字、字符串、列表、元组、字典</p><ul><li>数字类型存在复数（complex）</li><li>对于序列（字符串、列表、元组）存在双向索引，可以利用索引取子串（或间隔取子串）。可以使用 <code>+</code> 和 <code>*</code> 进行运运算。对于列表、元组、字典，其可以互相嵌套。</li></ul><h2 id="Python-运算符"><a href="#Python-运算符" class="headerlink" title="Python 运算符"></a>Python 运算符</h2><ul><li>与 C 语言不同的是，Python 采用 <code>//</code> 进行实数除运算，采用 <code>//</code> 进行整除运算，采用 <code>**</code> 进行幂运算</li><li><code>is</code> 和 <code>is not</code> 运算符用来比较两个标识符是否引自一个对象，而 <code>==</code> 用于判断引用变量的值是否相等。<code>id()</code> 用于得到引用变量的地址，<code>is</code> 相当于利用该函数比较地址是否相同。</li></ul><h2 id="Python-中的数据类型转换函数"><a href="#Python-中的数据类型转换函数" class="headerlink" title="Python 中的数据类型转换函数"></a>Python 中的数据类型转换函数</h2><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x[,base])</td><td>将字符串或浮点数转换为整型</td></tr><tr><td>long(x[,base])</td><td>同上</td></tr><tr><td>float(x)</td><td>略</td></tr><tr><td>complex(real[,image])</td><td>略</td></tr><tr><td>str(x)</td><td>将对象转化为字符串类型</td></tr><tr><td>repr(x)</td><td>将对象 x 转化为表达式字符</td></tr><tr><td>eval(x)</td><td>将字符串转换为表达式并进行计算返回对象</td></tr><tr><td>tuple(s)、list(s)、set(s)、dict(d)、frozenset(s)</td><td>略</td></tr><tr><td>chr(x)、unichr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将字符转换为整数</td></tr><tr><td>hex(x)</td><td>将一个整数转化为十六进制字符串</td></tr><tr><td>oct(x)</td><td>将整数转化为八进制字符串</td></tr></tbody></table></div><h2 id="Python-中的数学函数"><a href="#Python-中的数学函数" class="headerlink" title="Python 中的数学函数"></a>Python 中的数学函数</h2><p>以下函数需调用 math 库</p><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>abs(x)、ceil(x)、cmp(x,y)、floor(x)、log10(x)、max(x1,x2,…)、min(x1,x2,…)、pow(x,y)、sqrt(x)</td><td>略</td></tr><tr><td>fabs(x)</td><td>返回绝对值的浮点数形式</td></tr><tr><td>log(x[,base])</td><td>返回以base为底的x的对数</td></tr><tr><td>modf(x)</td><td>返回 x 的整数和小数部分</td></tr><tr><td>round(x[,n])</td><td>返回 x 的四舍五入的值，n 表示小数点后的位数</td></tr><tr><td>acos()、asin()、atan()、cos()、sin()、tan()</td><td>略</td></tr><tr><td>atan2(y,x)</td><td>返回对应坐标的反正切值</td></tr><tr><td>hypot(x,y)</td><td>返回直角三角形的斜边</td></tr><tr><td>degrees(x)、radians(x)</td><td>将弧度转化为角度、将角度转化为弧度</td></tr><tr><td>pi、e</td><td>数学常量</td></tr></tbody></table></div><h2 id="Python-中的字符串"><a href="#Python-中的字符串" class="headerlink" title="Python 中的字符串"></a>Python 中的字符串</h2><ul><li>可以使用 <code>&#39;xxxx%s&#39;(&#39;hello&#39;)</code> 的形式格式化字符串</li><li>python 三引号可以保留字符串原有格式</li><li>可以使用 <code>u&#39;xxx&#39;</code> 的格式定义一个 Unicode 字符串</li><li><a href="[Python 字符串 | 菜鸟教程 (runoob.com">更多关于字符串的函数</a>](<a href="https://www.runoob.com/python/python-strings.html">https://www.runoob.com/python/python-strings.html</a>))</li></ul><h2 id="Python-中的列表"><a href="#Python-中的列表" class="headerlink" title="Python 中的列表"></a>Python 中的列表</h2><p>支持 <code>for in</code> 语句。</p><p>元组内置函数同列表内置函数相同。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">cmp</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token comment"># 比价两个列表</span><span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token comment"># 得到列表长度</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token builtin">list</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token comment"># 将序列转化为列表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token builtin">list</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token builtin">list</span><span class="token punctuation">.</span>extend<span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token comment"># 拼接序列</span><span class="token builtin">list</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment"># 找到第一个匹配项的位置</span><span class="token builtin">list</span><span class="token punctuation">.</span>insert<span class="token punctuation">(</span>index<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token comment"># 向序列中插入新对象</span><span class="token builtin">list</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">[</span>index<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 移除列表中的一个元素，并返回值</span><span class="token builtin">list</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment"># 移除列表中的第一个匹配项</span><span class="token builtin">list</span><span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 翻转列表</span><span class="token builtin">list</span><span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token builtin">cmp</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 排序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python-中的字典"><a href="#Python-中的字典" class="headerlink" title="Python 中的字典"></a>Python 中的字典</h2><p>可以使用 <code>del</code> 删除字典中的某一个键值对</p><p>字典键的特性：</p><ol><li>不允许同一个键出现两次。对于同一个键，首先出现的键会被覆盖。</li><li>键不允许改变，因此需要以数字、字符串或元组充当。</li><li>键对应的值可以为任意对象。</li></ol><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">dict</span><span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">dict</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 返回一个字典的浅拷贝</span><span class="token builtin">dict</span><span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span>seq<span class="token punctuation">[</span><span class="token punctuation">,</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 创建一个薪资点，以 seq 中的元素作为键，其对应的值为 val</span><span class="token builtin">dict</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token comment"># 返回 key 对应的值，若键不存在返回 default</span><span class="token builtin">dict</span><span class="token punctuation">.</span>has_key<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token comment"># 判断字典中是否存在 key 键</span><span class="token builtin">dict</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 返回一个列表，以元组形式表示所有键值对</span><span class="token builtin">dict</span><span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>key<span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token comment"># 和 get 相似，但若不存在键则将添加键值对</span><span class="token builtin">dict</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>dict2<span class="token punctuation">)</span><span class="token comment"># 将 dict2 中内容并入 dict 中</span><span class="token builtin">dict</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token punctuation">,</span>default<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 删除并返回值</span><span class="token builtin">dict</span><span class="token punctuation">.</span>popitem<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 删除最后一对键值对</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python-中的函数"><a href="#Python-中的函数" class="headerlink" title="Python 中的函数"></a>Python 中的函数</h2><ul><li><p>参数传递</p><p>  在 python 中，类型属于对象，变量没有类型，可以将变量看做为一个指针，其可以指向任意数据类型，而其本身不属于任何类型。在 python 中，存在<strong>不可变类型</strong>，如数字、字符串、元组类型，也存在<strong>可变类型</strong>，如list、dict。在参数传递的过程中，不可变类型是<strong>值传递</strong>，而可变类型是<strong>引用传递</strong>。</p></li><li><p>参数列表</p><ul><li>必备参数：必须使用默认的参数顺序和参数数量</li><li>关键字参数：借用形参名称匹配传参，可以改变顺序</li><li>默认参数</li><li>不定长参数：在参数列表末尾追加元组指针<code>*var_args_tuple</code>即可。</li></ul></li><li><p>匿名函数（lambda函数）</p><p>  形如：<code>lambda [arg1[,arg2[,...]]]:expression</code> 返回表达式的值，其可以被赋值到一个变量中，该变量名即为函数名。</p></li></ul><h2 id="Python-文件-I-O"><a href="#Python-文件-I-O" class="headerlink" title="Python 文件 I/O"></a>Python 文件 I/O</h2><ul><li><p>打印：<code>print</code> 函数即可</p></li><li><p>读入：<code>input</code> ，返回读入的字符串</p></li><li><p>打开和关闭文件：使用 <code>open(file_name[,access_mode][,buffering]</code> 函数和 <code>close()</code> 方法。</p></li><li><p>file 文件的属性：<code>file.closed</code>、<code>file.mode</code>、<code>file.name</code>、<code>file.softspace</code></p></li><li><p>打开模式</p><p>  <img src="/2020/12/23/python-chong-wen/access-mode.png" alt="access mode"></p><p>  （图片引用自<a href="https://www.runoob.com/python/python-files-io.html">Python 文件I/O | 菜鸟教程 (runoob.com)</a>）</p></li><li><p>文件的写入：<code>write(str)</code> 方法</p></li><li><p>文件的读出：<code>read([count])</code> 方法，读取指定长度的字符串，否则读取整个文件。<code>readline([size])</code> 读取整行，<code>readlines([size])</code> 读取所有行并返回列表，<code>writelines(seq)</code>写入列表，需自己写入换行符。</p></li><li><p>文件定位：<code>tell</code> 方法告诉当前文件指针位置，<code>seek(offset[,from])</code> 方法用于重新定位指针位置</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论定理汇总(一)</title>
      <link href="2020/12/22/shu-lun-ding-li-hui-zong-yi/"/>
      <url>2020/12/22/shu-lun-ding-li-hui-zong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="数论定理汇总—一"><a href="#数论定理汇总—一" class="headerlink" title="数论定理汇总—一"></a>数论定理汇总—一</h1><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>已知两个数 $a$ 和 $b$，求 $gcd(a,b)$。</p><p>步骤：易证 $gcd(a,b)=gcd(b,a\bmod b)$，使用递归迭代求解直至 $b$ 为 0 时，$a$ 即为答案。</p><p>时间复杂度：$O(lgn)$</p><p>应用：可以求多个数的最大公因数。可以借助公式 $lcm(a,b)=\frac{a\cdot b}{gcd(a,b)}$ 求最小公倍数。</p><h3 id="扩展欧几里得定理"><a href="#扩展欧几里得定理" class="headerlink" title="扩展欧几里得定理"></a>扩展欧几里得定理</h3><p>用于求解 $ax+by=gcd(a,b)$ 的一组可行解。</p><p>步骤：构造方程组</p><script type="math/tex; mode=display">\begin{cases}ax_1+by_1=gcd(a,b)\\bx_2+(a\bmod b)y_2=gcd(b,a\bmod b)\end{cases}</script><p>解得</p><script type="math/tex; mode=display">\begin{cases}x_1=y_2\\y_1=x_2-\lfloor\frac{a}{b}\rfloor\end{cases}</script><p>依次关系构造递归函数求解即可。</p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>欧拉函数 $\phi(n)$，表示的是小于等于 $n$ 且和 $n$ 互质的数的个数。</p><p>性质：</p><ul><li>欧拉函数是积性函数，当 $gcd(a,b)=1$ 时，满足 $\phi(a\times b)=\phi(a)\times\phi(b)$。</li><li>$n=\sum_{d|n}\phi(d)$</li><li>若 $n=p^k$，且 $p$ 为质数，则 $\phi(n)=p^k-p^{k-1}$</li><li>设 $n=\prod_{i=1}^np_i^{k_i}$，其中 $p_i$ 为质数，则有 $\phi(n)=n\cdot\prod_{i=1}^n\frac{p_i-1}{p_i}$</li></ul><p>应用：</p><p>欧拉定理：若 $gcd(a,b)=1$，则 $a^{\phi(b)}\equiv 1 (\bmod b)$</p><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="埃拉托斯特尼筛"><a href="#埃拉托斯特尼筛" class="headerlink" title="埃拉托斯特尼筛"></a>埃拉托斯特尼筛</h3><p>使用已求得素数的倍数筛去合数。</p><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><p>优化了埃氏筛以防止重复筛掉同一数字。</p><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>定义：若 $p$ 为素数，$gcd(a,p)=1$，则 $a^{p-1}\equiv1(\bmod p)$，或 $a^p\equiv a(\bmod p)$</p><ul><li><p>证明一：构造序列 $A=\{1,2,\cdots,p-1\}$，可得等式</p><script type="math/tex; mode=display">  \prod_{i=1}^{p-1}A_i=\prod_{i=1}^{p-1}A_i\cdot a\quad(\bmod p)\quad(1)</script><p>  下证该等式：</p><script type="math/tex; mode=display">  gcd(A_i\cdot a,p)=1\\  gcd(a,p)=1\\  A_i\cdot a\bmod p\neq A_j\cdot a\bmod p\quad(if\quad i\neq j)</script><p>  使用上述三个等式即可证明等式 $(1)$</p><p>  展开等式 $(1)$ 易得 $a^{p-1}\equiv1(\bmod p)$</p></li><li><p>证明二：使用数学归纳法+二项式定理证明</p><p>  显然</p><script type="math/tex; mode=display">  1^{p}\equiv 1\quad (\bmod p)</script><p>  假设当 $a\leq a$ 时 $a^p\equiv a(\bmod p)$ 成立，则由二项式定理</p><script type="math/tex; mode=display">  (a+1)^p=a^p+\binom{p}{1}a^{p-1}+\binom{p}{2}a^{p-1}+\cdots+1</script><p>  而对于 $\binom{p}{i}(i&lt;p)$ 其必然可以被 $p$ 整除，因此 $(a+1)^p \bmod p=a+1$，得证。</p></li></ul><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若 $gcd(a,b)=1$，则 $a^{\phi(b)}\equiv 1 (\bmod b)$</p><p>证明：其与费马小定理证明类似，唯一不同的是构造序列 $A$ 时，$A$ 需为模 $b$ 意义下的一个简化剩余系(简化剩余系为所有与 $b$ 互质的数组成集合的子集)。存在性质，若 $A$ 为 $b$ 的简化剩余系，则 $\{a\cdot A_i\}$ 也为 $b$ 的一个简化剩余系。</p><h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>暂时用不到，就先把定理内容放在上边。</p><script type="math/tex; mode=display">a^b\equiv\begin{cases}a^{b\bmod \phi(p)},&gcd(a,p)=1\\a^b,&gcd(a,p)\neq1,b<\phi(p)\\a^{b\bmod \phi(p)+\phi(p)},&gcd(a,p)\neq1,b\geq \phi(p)\end{cases}\quad(\bmod p)</script><h2 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h2><p>使用 $O(lgn)$ 的时间复杂度求解形如</p><script type="math/tex; mode=display">f(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor</script><ul><li><p>处理一：</p><p>  若 $a\geq c$ 或 $b \geq c$，可以使用整除理论对式子进行化简，化简结果如下：</p><script type="math/tex; mode=display">  f(a,b,c,n)=\lfloor\frac{a}{c}\rfloor\frac{n(n+1)}{2}+\frac{b}{c}n+f(a\bmod c,b\bmod c,c,n)</script></li><li><p>处理二：</p><script type="math/tex; mode=display">  \begin{aligned}  f(a,b,c,n)&=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor\\  &=\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor-1}1\\  &=\sum_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\sum_{i=0}^n[j<\lfloor \frac{ai+b}{c}\rfloor]\\  &=\sum_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\sum_{i=0}^n[\lfloor\frac{jc+c-b-1}{a}\rfloor<i]\\  &=\sum_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}n-\lfloor\frac{jc+c-b-1}{a}\rfloor\\  &=n\cdot\lfloor\frac{an+b}{c}\rfloor-f(c,c-b-1,a,\lfloor\frac{an+b}{c}\rfloor-1)  \end{aligned}</script><p>  令 $m=\lfloor\frac{an+b}{c}\rfloor$，即有</p><script type="math/tex; mode=display">  f(a,b,c,n)=n\cdot m-f(c,c-b-1,a,m-1)</script><p>  使用欧几里得算法类似的思想进行迭代处理即可求解相应问题。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 欧几里得算法 </tag>
            
            <tag> 欧拉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包九讲学习笔记</title>
      <link href="2020/12/18/bei-bao-jiu-jiang-xue-xi-bi-ji/"/>
      <url>2020/12/18/bei-bao-jiu-jiang-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="背包九讲学习笔记"><a href="#背包九讲学习笔记" class="headerlink" title="背包九讲学习笔记"></a>背包九讲学习笔记</h1><blockquote><p>“失败不是什么丢人的事情， 从失败中全无收获才是。”<br>                                                                                            ——崔添翼</p></blockquote><h2 id="1st-01背包问题"><a href="#1st-01背包问题" class="headerlink" title="1st_01背包问题"></a>1st_01背包问题</h2><p>$f[i][j]$ 表示前 $i$ 件物品在容量为 $j$ 的背包中所能获取到的最大价值。状态 $f[i][j]$ 是由<strong>先前状态+决策</strong>得到的，<strong>先前状态</strong>是指我们已知前 $i-1$ 件物品在容量为 $0-j$ 的背包中取值的最优解(即得到最大价值)，<strong>决策</strong>是指我们从前 $i-1$ 件物品的最优解到前 $i$ 件物品的最优解需要作出的选择。在这里，我们需要作出的选择有两种，一种是不将第 $i$ 件物品加入背包，一种是将第 $i$ 件物品加入背包，并从可选择的决策中选出最优的决策，其对应状态方程</p><script type="math/tex; mode=display">f[i][j]=max(f[i-1][j],f[i-1][j-c[i]])</script><p>若我们能够保证 $f[i-1][0…j]$ 是最优解，则我们由此得到的 $f[i][j]$ 必然也是最优解。<br>C++实现代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; c[i] 表示第 i 件物品所占用体积，w[i] 表示第 i 件物品的价值for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)    for(int j &#x3D; 1; j &lt;&#x3D; m; ++j)        dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-c[i]]+w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2nd-完全背包问题"><a href="#2nd-完全背包问题" class="headerlink" title="2nd_完全背包问题"></a>2nd_完全背包问题</h2><p>与 <a href="#1_st01背包问题">01 背包问题</a> 的不同，在完全背包问题中，每一种物品都有无数个。沿用01背包状态<strong>先前状态+决策</strong>的思想，这里 $dp[i][j]$ 可以由若干决策得到，第 $k$ 个决策表示取 $k$ 个第 $i$ 种物品放入背包，我们要从这些决策中挑选出最优策略，只需添加一个循环语句即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)    for(int j &#x3D; 1; j &lt;&#x3D; m; ++j)        for(int k &#x3D; 1; k &lt;&#x3D; j&#x2F;c[i]; ++k)            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码时间复杂度为 $O(n^3)$，可以通过推导公式得到一个优化，考虑：</p><script type="math/tex; mode=display">\begin{aligned}dp[i][j] &= max(dp[i-1][j], dp[i-1][j-k\cdot c[i]] + k\cdot w[i]), k\in(1,\lfloor{\frac{j}{c[i]}}\rfloor)\\dp[i][j-c[i]] &= max(dp[i-1][j-c[i]], dp[i-1][j-c[i]-k\cdot c[i]] + k\cdot w[i]), k\in(1,\lfloor{\frac{j-w[i]}{c[i]}}\rfloor)\end{aligned}</script><p>可以发现</p><script type="math/tex; mode=display">\begin{aligned}&max(dp[i-1][j-k\cdot c[i]] + k\cdot w[i])(k\in(1,\lfloor{\frac{j}{c[i]}}\rfloor)\\=&max(dp[i-1][j-c[i]]+w[i], dp[i-1][j-(k+1)\cdot w[i]]+(k+1)\cdot w[i])(k\in(1,\lfloor{\frac{j}{c[i]}}\rfloor-1)\\=&max(dp[i-1][j-c[i]]+w[i], dp[i-1][j-c[i]-k\cdot c[i]] + k\cdot w[i] + w[i]), k\in(1,\lfloor{\frac{j-w[i]}{c[i]}}\rfloor)=&dp[i][j-c[i]]+w[i]\end{aligned}</script><p>因此得到<strong>优化公式</strong>：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i]) = max(dp[i-1][j], dp[i][j-c[i]] + w[i])</script><p>故化简后的递推方程为：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j], dp[i][j-c[i]] + w[i])</script><p>该公式表示 $max(dp[i-1][j-k\cdot c[i]]+k\cdot w[i])$ 与 $dp[i][j-c[i]] + w[i]$ 的值是相同的，因此可将上述代码中 $O(n^3)$ 的时间复杂度减少为 $O(n^2)$ 的时间复杂度。<br>上述是数学上的证明，也可以通过递归状态来理解<strong>优化公式</strong>。若前 $i$ 种物品可选，背包容量为 $j$，若想得到最优解，可以通过两种策略得到。一种是根本不选第 $i$ 种物品，则 $dp[i][j] = dp[i-1][j]$，另一种是选择第 $i$ 种物品，此时我们有最优状态 $dp[i][1…j-1]$(在这些状态中我们可能已经选择了第 $i$ 件物品)，可以基于此来得到若再次选择第 $i$ 件物品的价值 $dp[i][j] = dp[i][j-c[i]]$。由此思想也可以得到上述递推方程式。</p><p><strong>一个简单的优化</strong></p><p>在解决问题之前，有一个 $O(n^2)$ 的算法可以对其进行优化。即对所有物品进行两两比较，若存在 $c[i] &lt; c[j]$ 且 $w[i] &gt; w[j]$，则可以抛弃物品 $j$。</p><h2 id="3rd-多重背包问题"><a href="#3rd-多重背包问题" class="headerlink" title="3rd_多重背包问题"></a>3rd_多重背包问题</h2><h3 id="多重背包的-O-n-sum-logm-解法"><a href="#多重背包的-O-n-sum-logm-解法" class="headerlink" title="多重背包的 $O(n\sum logm)$ 解法"></a>多重背包的 $O(n\sum logm)$ 解法</h3><p>多重背包问题介于 01 背包问题和完全背包问题，其规定每一种物体最多可用 $M_i$ 个。考虑将其转化为 01 背包问题，则其相当于有 $\sum M_i$ 个物品的 01 背包问题(相当于将 1 种物品看做 $M_i$ 个不同的物品)。如果这样的话，则其时间复杂度为$O(n\cdot \sum M_i)$ ，时间复杂度较大，应考虑优化。</p><p>我们使用二进制的思想进行优化。考虑这样一个问题，对于数字 10，我们可以通过$a[1]\cdot 1+a[2]\cdot 1+…+a[10]\cdot 1$的方式取得$1-10$以内的所有值，其中$a[i]\in\{0,1\}$，我们也有另一种方式取到$1-10$以内的值，考虑$a[1]\cdot 1+a[2]\cdot 2+a[3]\cdot 2^2+a[4]\cdot (10-1-2-2^2)$，同样可以达到目标。使用相同的思想，对于第 $i$ 种物品，可以进行相关的划分，不再将其看成 $M_i$ 个独立的物品，而是将其划分成若干组，这些组中分别含有 $\{2^0,2^1,2^2,…2^{k-1},M_i-2^k+1\}$ 个第 $i$ 种物品，通过这些组的组合，我们可以得到范围内任意数量的第 $i$ 种物品，而我们将每一组看成一个独立的物品，其容量为 $m_k\cdot c[i]$ ，价值为 $m_k\cdot w[i]$，$m[1…k+1]=\{2^0,2^1,2^2,…2^{k-1},M_i-2^k+1\}$。</p><p>使用上述思想求解问题，问题的时间复杂度就降为$O(n\cdot \sum logm_i)$，大大降低了时间复杂度。貌似可以使用优先队列优化，但好像考题很少，此处略过~~~。</p><p>实现代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void OneZeroPack(int * dp, int n, int c, int w)&#123;    for(int i &#x3D; n; i &gt;&#x3D; c; --i)        dp[i] &#x3D; max(dp[i], dp[i-c]+w);&#125;void CompletePack(int * dp, int n, int c, int w)&#123;    for(int i &#x3D; c; i &lt;&#x3D; n; ++i)        dp[i] &#x3D; max(dp[i], dp[i-c]+w);&#125;&#x2F;&#x2F; m 表示该物品最多的个数void MultiplePack(int * dp, int n, int c, int w, int m)&#123;    if(c*m &gt;&#x3D; n)&#123;        &#x2F;&#x2F; 转化为完全背包问题        CompletePack(dp, n, c, w);        return;    &#125;    int k &#x3D; 1;    while(k &lt; m)&#123;        OneZeroPack(dp, n, k*c, k*w);        m -&#x3D; k;        k &lt;&lt;&#x3D; 1;    &#125;    OneZeroPack(dp, n, m*c, m*w);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多重背包可行性问题的-O-VN-解法"><a href="#多重背包可行性问题的-O-VN-解法" class="headerlink" title="多重背包可行性问题的 $O(VN)$ 解法"></a>多重背包可行性问题的 $O(VN)$ 解法</h3><p>若只考虑“每种有若干件的物品能否恰好填满背包”，而不考虑每一件物品的价值，那么有着 $O(N)$ 的算法。使用 $f[i][j]$ 表示 “使用前 $i$ 件物品恰好填满了容量为 $j$ 的背包后，最多还剩下第 $i$ 件物品的件数” ，若 $F[i][j]=-1$ 表示前 $i$ 件物品无法恰好填满容量为 $j$ 的背包。可以写出以下代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; m; ++i)    dp[i] &#x3D; -1;dp[0] &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;    &#x2F;&#x2F; 从前 i-1 件物品转移到前 i 件物品    for(int j &#x3D; 1; j &lt;&#x3D; m; ++j)        dp[j] &#x3D; dp[j] &#x3D;&#x3D; -1 ? -1 : num[i];    &#x2F;&#x2F; 试图填满之前无法填满的背包    for(int j &#x3D; c[i]; j &lt;&#x3D; m; ++j)        &#x2F;&#x2F; 状态为 j 时是否使用第 i 件物品        if(dp[j-c[i]] &gt; 0)        dp[j] &#x3D; max(dp[j], dp[j-c[i]] - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4th-混合三种背包问题"><a href="#4th-混合三种背包问题" class="headerlink" title="4th_混合三种背包问题"></a>4th_混合三种背包问题</h2><p>如果在一个背包中，有的物体的个数有限、有的物体的个数仅有一个、有的物体的个数无限多个，这就是混合三种背包问题，对此，只需要将上述代码综合起来即可。伪代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)    if 第 i 种物品有一个        ZeroOnePack(dp, m, c[i], w[i]);else if 第 i 种物品有无限个        CompletePack(dp, m, c[i], w[i]);else 第 i 种物品有 num 个        MultiplePack(dp, m, c[i], w[i], num);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5th-二维费用的背包问题"><a href="#5th-二维费用的背包问题" class="headerlink" title="5th_二维费用的背包问题"></a>5th_二维费用的背包问题</h2><p>二维费用的背包问题指对于每件物品有 $C$、$D$ 两种容量，同时对于这两种费用背包各有一个容量上限，在此基础上求背包所能达到的最大价值。</p><p>设 $f[i][u][v]$ 表示前 $i$ 件物品中背包的两种容量分别为 $u$ 和 $v$ 的情况下所能取得的最大价值，状态方程如下</p><script type="math/tex; mode=display">f[i][u][v]=max(f[i-1][u][v], f[i-1][u-C_i][v-D_i]+w[i])</script><p>给出伪代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)    for(int j &#x3D; s; j &gt;&#x3D; c[i]; --j)        for(int k &#x3D; t; k &gt;&#x3D; d[i]; --k)            f[j][k] &#x3D; max(dp[s][t], dp[s-c[i]][t-d[i]] + w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6th-分组的背包问题"><a href="#6th-分组的背包问题" class="headerlink" title="6th_分组的背包问题"></a>6th_分组的背包问题</h2><p>有 $n$ 个物品，将其划分为 $k$ 组，每一组内部的物品最多选取一件，试求出该背包问题的最大解法。设 $dp[k][j]$ 表示前 $k$ 组在容量为 $j$ 的背包中的最大价值，其与 <a href="#1st_01背包问题">01背包</a> 的区别是：<strong>前者的决策是决定在第 $k$ 组中是否选出物品以及选出哪一个物品，后者是决定第 $i$ 件物品是否选中</strong>。递推方程如下：</p><script type="math/tex; mode=display">dp[k][j] = max(dp[k-1][j], dp[k-1][j-c[k][i]] + w[k][i] | i\in (1,num[k]))</script><p>其中 $c[k][i]$ 和 $w[k][i]$ 表示第 $k$ 组中第 $i$ 个物品的容量和价值，$num[k]$ 表示第 $k$ 组物品的数目。</p><p>给出代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int k &#x3D; 1; k &lt;&#x3D; K; ++k)    for(int j &#x3D; m; j &gt;&#x3D; 1; ++j)        for(int i &#x3D; 1; i &lt;&#x3D; num[k]; ++i)            if(j &gt;&#x3D; c[k][i])                dp[j] &#x3D; max(dp[j], dp[j-c[k][i]] + w[k][i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7th-有依赖的背包问题"><a href="#7th-有依赖的背包问题" class="headerlink" title="7th_有依赖的背包问题"></a>7th_有依赖的背包问题</h2><p>若选择了物品 $j$ ，则必须先选择物品 $i$，我们称物品 $j$ 依赖于物品 $i$。有依赖的背包问题指的就是当背包中的物品满足若干依赖关系式如何对该类问题进行求解。简化问题，我们仅假设依赖没有连续性，即不会出现 $A$ 依赖于 $B$，而 $B$ 依赖于 $C$ 的情况；又假设一件物品只能依赖于一件物品。</p><p>下面的话完全引用自崔添翼的背包九讲(但是我添加了部分锚点)，<del>—我实在无法找到更美妙的描述了—</del></p><blockquote><p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有 $n$ 个附件，则策略有 $2^n + 1$ 个，为指数级。</p><p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于<a href="#6th_分组的背包问题">分组背包</a>中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</p><p>再考虑对每组内的物品应用<a href="#2nd_完全背包问题">完全背包</a>中的优化。我们可以想到，对于第 $k$ 个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，可以对主件 $k$ 的 “附件集合”先进行一次 01 背包，得到费用依次为 $0…V-C_k$ ，所有这些值时相应的最大价值 $F_k[0…V − C_k]$。那么，这个主件及它的附件集合相当于 $V − C_k + 1$ 个物品的物品组，其中费用为 $v$ 的物品的价值为 $F_k[v − C_k] + W_k$，$v$ 的取值范围是 $C_k ≤ v ≤ V$。</p><p>也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后， 将主件 $k$ 及其附件转化为 $V − C_k + 1$ 个物品的物品组，就可以直接应用<a href="#2nd_完全背包问题">完全背包</a>的算法解决问题了。</p></blockquote><p>实现代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算第 k 个物品组</span><span class="token comment">// 得到重量为 0~m-c[k][0]，价值为 f[k][0]~f[k][m-c[k][0]] 的物品</span><span class="token comment">// 这些物品代表同等重量中价值最高的物品组合</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token operator">-</span>c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>        f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> K<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m <span class="token operator">-</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> i <span class="token operator">-</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在考虑更加一般的情况。如果每个物品仍然只能依赖于一个物品，但是可以连续以来(不能循环依赖)，就构成了若干依赖树，那么该如何求解呢?可以采用相同的思路。仍然可以将一个主件即其附件集合看做一个物品组，但是由于其附件还有附件，因此需要先将其附件以及附件的附件看做一个物品组，以此类推。每当要求一个根节点的物品组时，先求得其子节点的物品组，这是一种树形动态规划的形式。</p><p>需要注意的是，我发现以上方法虽然通用但不代表是最优解。对组内进行朴素分组的时间复杂度为 $O(2^n)$，而通过上述方法进行分组的时间复杂度为 $O(k\cdot C)$，其中 $C$ 表示背包的容量。看似我们大大降低了时间复杂度，但是当面对 $n$ 较小而 $C$ 较大的情况时往往采用朴素分组的时间复杂度会更优。例子可以参考 <a href="https://www.luogu.com.cn/problem/P1064">金明的预算方案</a>。虽然如此，我认为上述方法对于思维的开拓是极其具有意义和价值的。</p><h2 id="8th-泛化物品"><a href="#8th-泛化物品" class="headerlink" title="8th_泛化物品"></a>8th_泛化物品</h2><p><strong>泛化物品</strong>是对背包内可装入的物品的一个更加抽象与广义的概念。其没有固定体积和价值，其价值随着被分配给它的体积而变化。即其价值与体积为一个函数关系，满足 $w=f(c)$，我们可称此方程为<strong>泛化函数</strong>。</p><p>对于一个容量为 $c$，价值为 $w$ 的物品，在 01 背包问题中其<strong>泛化函数</strong>为</p><script type="math/tex; mode=display">f(x)=\begin{cases}w,x=c\\0,x\neq c\end{cases}</script><p>在完全背包中其泛化函数为</p><script type="math/tex; mode=display">f(x)=\begin{cases}\frac{x}{c}*w,c\mid x\\0,c \nmid x\end{cases}</script><p>多重背包同理。</p><p>一个物品组也可以看做一个泛化物品。若物品组中存在容量为 $c$ 的物品，则 $f(c)$ 为所有容量为 $c$ 的物品中的最大价值，若不存在容量为 $c$ 的物品，则 $f(c)=0$。同样，对于<a href="#7th_有依赖的背包问题">依赖背包</a>问题，我们可以按照之前所述的两种方式对其进行分组，得到一个依赖分组中的泛化函数。</p><p>现在有两个泛化物品 $h$ 和 $l$ ，若给定他们以最大空间 $v$，通过分配 $h$ 和 $v$ 不同的空间，求得 $v$ 所能够得到的最大价值 $f(v)$，$f(v)$ 满足</p><script type="math/tex; mode=display">f(v) = max\{h(x) + l(v-x)|0\leq x\leq v\}</script><p>而通过 $v$ 的不同取值，我们可以得到一个新的泛化物品 $f$，其代表泛化物品 $h$ 和 $l$ 的和。此时以 $f$ 代替物品 $h$ 和 $l$，结果不会受到任何影响。</p><p>求解背包问题，就是不断地合并泛化物品并求解泛化物品最大值的过程，其通用形式如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 集合 S 表示一个泛化物品的集合for k in S    for v &lt;- C to 0        &#x2F;&#x2F; 合并泛化物品 obj 和 k，更新泛化物品 obj        obj[v] &lt;- max(obj[v - x] + k[x])return obj[C]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9th-背包问题的变化"><a href="#9th-背包问题的变化" class="headerlink" title="9th_背包问题的变化"></a>9th_背包问题的变化</h2><p>这里我会专门再写一篇博客来探究背包问题的不同问法，此处先留个坑。^ _ ^</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础图上问题小结</title>
      <link href="2020/12/18/ji-chu-tu-shang-wen-ti-xiao-jie/"/>
      <url>2020/12/18/ji-chu-tu-shang-wen-ti-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构图小结"><a href="#数据结构图小结" class="headerlink" title="数据结构图小结"></a>数据结构图小结</h1><blockquote><p>这篇小结中的所有题目均来自洛谷的”图的基本应用”题单。其中主要涉及到的相关知识有：dfs 和 bfs 的基本应用，根据 dfs 求有向无环图中最大路径、路径数量，根据拓扑排序判断图中是否有环的存在以及能否形成稳定的有序序列，找出图中的欧拉通路。</p></blockquote><p>[TOC]</p><h2 id="P5318-查找文献（dfs和bfs基本应用）"><a href="#P5318-查找文献（dfs和bfs基本应用）" class="headerlink" title="P5318_查找文献（dfs和bfs基本应用）"></a>P5318_查找文献（dfs和bfs基本应用）</h2><ul><li><p><a href="https://www.luogu.com.cn/problem/P5318">题目连接</a></p></li><li><p>题目描述：给定一个有向图，输出深搜和广搜的结果，但是必须保证输出结果的字典序尽可能的小</p></li><li><p>解题思路：<br>  该题的难点在保证输出字典序尽可能小，因此需要对每一个点的邻接点按照序号进行排序，随后 dfs、bfs 即可</p></li><li><p>核心代码</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; q 是用于存储邻接表的 vector 数组for(int i &#x3D; 0; i &lt; m; ++i)&#123;    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);    q[a].push_back(b);&#125;for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;    sort(q[i].begin(), q[i].end());&#125;&#x2F;&#x2F; 随后根据排序后的邻接表深搜和广搜即可dfs();bfs();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P3916-图的遍历（dfs查找到达的最大顶点）"><a href="#P3916-图的遍历（dfs查找到达的最大顶点）" class="headerlink" title="P3916_图的遍历（dfs查找到达的最大顶点）"></a>P3916_图的遍历（dfs查找到达的最大顶点）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P3916">题目链接</a></p></li><li><p>题目描述：给定一个有向图，有 n 个点， m 条边，其中点从 1 到 n 进行编号。确定每个点所能到达的最大点的编号</p></li><li><p>解题思路：<br>  这道题本质是一个深度优先搜索，对每一个点进行搜索即可。但是关键的一点是从第 n 个点开始搜索，第 n 个点所到达的点的最大值必然是 n，同时将其进行标记；随后从第 n-1 个点开始搜索，对于所有未被访问过的点来说，如果其能被第 n-1 个点到达，那么其可到达的最大值必然是 n-1，以此类推，直到第 1 个点为止。</p></li><li><p>核心代码</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int p, int v)&#123;    a[p] &#x3D; v;   &#x2F;&#x2F; 记录点 p 可以到达的编号最大的点    vis[p] &#x3D; true;    for(int k &#x3D; head[p]; k; k &#x3D; edges[k].next)&#123; &#x2F;&#x2F; 继续寻找点 v 可以到达的点        if(!vis[edges[k].to])            dfs(edges[k].to, v);    &#125;&#125;&#x2F;&#x2F; 从第 n 个点开始倒序搜索for(int i &#x3D; n; i &gt;&#x3D; 1; --i)&#123;    if(!vis[i]) dfs(i, i);  &#x2F;&#x2F; 若点 i 已经被访问，则点 i 可以到达的顶点也一定已经被访问了                            &#x2F;&#x2F; 此时无需 dfs&#125;&#x2F;&#x2F; 输出结果for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;    printf(&quot;%d &quot;, a[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1113-杂务（dfs查找固定终点的最长路径）"><a href="#P1113-杂务（dfs查找固定终点的最长路径）" class="headerlink" title="P1113_杂务（dfs查找固定终点的最长路径）"></a>P1113_杂务（dfs查找固定终点的最长路径）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1113">题目链接</a></p></li><li><p>题目描述：John 在给奶牛挤奶前需要完成许多杂务，只有一些杂务已经被完成之后某些杂物才能开始去做。例如，如果想要完成杂务<code>D</code>，而杂务<code>D</code>需要在<code>A</code>、<code>B</code>都已经完成的情况下才能开始做。完成每个杂务都需要一定的时间，而农场中有足够的工人去同时去做没有依赖关系的杂务，求完成所有杂务所需的最短时间。</p></li><li><p>解题思路：<br>  使用深搜的思想来解决拓扑排序的问题。假设杂务<code>D</code>需要<code>A</code>、<code>B</code>都完成后才能开始，设 <code>t[D]</code> 为完成杂务D所需的最短时间，则 <code>t[D] = min(t[A], t[B])</code>，而完成A，B所需的最短时间以此类推，直到没有前一项杂务为止。</p></li><li><p>核心代码</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; v[maxn];int dfs(int p)&#123;    int len &#x3D; v[p].size();    int mx &#x3D; 0;    for(int i &#x3D; 0; i &lt; len; ++i)&#123;        &#x2F;&#x2F; 使用记忆化搜索可以极大的减少时间        if(!vis[v[p][i]]) mx &#x3D; max(dfs(v[p][i]), mx);        else mx &#x3D; max(vis[v[p][i]], mx);    &#125;    vis[p] &#x3D; mx + t[p]; &#x2F;&#x2F; 记录完成杂务 p 所需时间    return vis[p];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>相似题型：<a href="https://www.luogu.com.cn/problem/P4017">P4017最大食物链计数</a>该题求一个有向无环图中从头至尾链的数目，用的同样是 dfs 的思想来解决拓扑排序的问题。</li></ul><h2 id="P1807-最长路（dfs查找固定起点和终点的最长路径）"><a href="#P1807-最长路（dfs查找固定起点和终点的最长路径）" class="headerlink" title="P1807_最长路（dfs查找固定起点和终点的最长路径）"></a>P1807_最长路（dfs查找固定起点和终点的最长路径）</h2><ul><li><p><a href="https://www.luogu.com.cn/problem/P1807">题目链接</a></p></li><li><p>题目描述：给定一个有向无环图，有 n 个顶点 m 条边，顶点从 1 至 n 进行编号，边有权值，可以为负权。求出从点 1 到点 n 的最大路径，若不连通则输出-1。</p></li><li><p>解题思路：同样的深搜。其与上一题的区别在于对递归边界返回值的处理。</p></li><li><p>核心代码</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 返回点 p 到达 1 的最长距离int dfs(int p)&#123;    if(p &#x3D;&#x3D; 1) return 0;    int mx &#x3D; -INF, v;    vis[p] &#x3D; true;    for(int k &#x3D; head[p]; k; k &#x3D; edges[k].nxt)&#123;        v &#x3D; edges[k].v;        if(!vis[v]) dfs(v); &#x2F;&#x2F; 递归的求解点 p 到点 1 的最长距离        &#x2F;&#x2F; 如果联通，则找到最大的子路径        if(len[v] !&#x3D; INF) mx &#x3D; max(mx, len[v] + edges[k].w);    &#125;    if(mx &#x3D;&#x3D; -INF) mx &#x3D; INF;    return len[p] &#x3D; mx;&#125;&#x2F;&#x2F; 随后从点 n 开始 dfs 即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1127-词链（求欧拉通路）"><a href="#P1127-词链（求欧拉通路）" class="headerlink" title="P1127_词链（求欧拉通路）"></a>P1127_词链（求欧拉通路）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1127">题目链接</a></p></li><li><p>题目描述：如果单词 x 的尾字母和单词 y 的首字母相同，则单词 x 可以和单词 y 首尾相连成词链 x.y。现给定一些单词，找出字典序最小的词链，并且所有单词在该词链中出现并且只出现一次。</p></li><li><p>基础知识：该题是一道求<strong>欧拉通路</strong>的题。由于我离散数学学的不是很好，因此还不得不百度了一下如何求欧拉通路QAQ。因此需要明确一些欧拉通路的概念。</p><ul><li><strong>欧拉通路</strong>：通过图中的每条边且仅通过一次，并且通过每一个顶点的路径</li><li><strong>欧拉回路</strong>：通过图中的每条边且仅通过一次，并且通过每一个顶点的回路</li><li><strong>判断欧拉通路是否存在</strong>：对于无向图，该图必须联通，有且仅有两个顶点的度数为奇数，其余顶点的度数为偶数，且该两个顶点为欧拉通路的两端；对于有向图，该有向图的基图需联通（将所有有向边变为无向边），有且仅有两个顶点的出度和入度不相等，且一个顶点的出度比入读大 1（通路起点），一个顶点的入读比出度大 1（通路终点），其他所有顶点出度和入度相同。</li><li><strong>判断欧拉回路是否存在</strong>：对于无向图，其所有顶点的度数都为偶数；对于有向图，其所有顶点的出度和入读相同。<br>  <img src="/2020/12/18/ji-chu-tu-shang-wen-ti-xiao-jie/Euler.PNG" alt="euler_step"></li><li><strong>求解欧拉通路/回路的步骤</strong>：<ul><li>注：此处仅以<strong>有向图的欧拉通路</strong>为例，并且假设通路起点入读为 0，出度为 1，终点出度为 0，入读为 1。在我们的遍历过程中，我们每从一个顶点出发，该顶点的出度 -1，每进入一个顶点，该顶点的入读 -1。</li><li><strong>step1</strong>：首先我们可以轻易的<strong>确定欧拉通路的开始顶点</strong>，如上图所示，开始顶点为 <code>A</code>，随后我们以 <code>A</code> 为起点开始dfs。如 <code>step1</code>，假设我们访问到了顶点 <code>H</code>，若 <code>H</code> 非回路终点，那么由于<strong>出度与入读相同</strong>，则其必有一条边可以使我们继续向下访问，接下来我们访问到点 <code>I</code>，若 <code>I</code> 同样不是通路终点，则我们同样一定可以继续走下去。</li><li><strong>step2</strong>：我们将如同step1中所示持续向下访问，直到我们到达<strong>通路终点</strong> <code>Z</code>，由于其出度为 0，我们无法继续向下访问，此时我们可以得到一条路径<code>&quot;A-&gt;H-&gt;I-&gt;Y-&gt;Z&quot;</code>，通常情况下此条路径无法遍历有向图中所有的顶点，因此我们需要继续拓展到其他的点。</li><li><strong>step3</strong>：我们访问完 <code>Z</code> 之后，开始<strong>回退</strong>，回到上一次的顶点 <code>Y</code>，若 <code>Y</code> 的边已经被遍历完毕，则我们继续回退，回到顶点 <code>I</code>，此时我们发现 <code>I</code> 有其他的边，这是我们开始以 <code>I</code> 为起点进行 dfs，当从 <code>I</code> 出发时，此时 <code>I</code> 的入读比出度大 1。同样的，由于从 <code>I</code> 点开始 dfs 所访问到的顶点的出度与入读相同，因此 dfs 最终将只能在入读比出度小 1 的顶点（即点 <code>I</code>）终止。我们可得到一条回路 <code>&quot;I-&gt;N-&gt;M-&gt;I&quot;</code></li><li><strong>step4</strong>：深搜完点 <code>I</code> 之后，我们将回退点 <code>N、M</code>，若 <code>N、M</code> 没有多余边，则继续回退，此时回退到点 <code>H</code>，依照步骤4，我们访问到了 <code>G</code> 点并回到 <code>H</code></li><li><strong>step5</strong>：在 <code>step4</code> 中，当我们回到 <code>G</code> 后，需要对从 <code>G</code> 点出发深搜到的点进行回退，假设我们回退到点 <code>G</code>，发现点 <code>G</code> 仍有其他边，则从 <code>G</code> 出发开始深搜，搜到了 <code>D</code> 和 <code>E</code>，随后结束搜索。若此时图中的所有边都已经被遍历，则我们将持续回退，直到回退到点 <code>A</code>，结束欧拉通路的查找。</li><li>如果我们在某一节点回退结束时输出当前节点，则最后我们可以得到序列 <code>&quot;Z Y I M N I H G D E G H A&quot;</code></li></ul></li><li><p>具体查找欧拉通路的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 使用邻接矩阵进行dfs得到欧拉回路，实际操作中建议使用前向星或邻接表&#x2F;&#x2F; 此处给出无向图查找欧拉通路，有向图可以自己写写试试看int graph[maxn][maxn];int path[maxn], cnt &#x3D; 0, vis[maxn];int n, m;void dfs(int p)&#123;    for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;    &#x2F;&#x2F; 遍历顶点 p 的所有邻接点        if(graph[p][i])&#123;            --graph[p][i];  &#x2F;&#x2F; 减去顶点的度数            --graph[i][p];            dfs(i);        &#125;    &#125;    path[cnt++] &#x3D; p;    &#x2F;&#x2F; 遍历完点 p 的所有邻接边之后存储点 p&#125;int main()&#123;    int u, v;    cin&gt;&gt;n&gt;&gt;m;    for(int i &#x3D; 0; i &lt; m; ++i)&#123;        scanf(&quot;%d %d&quot;, &amp;u, &amp;v);        ++graph[u][v];        ++graph[v][u];    &#125;    dfs(1);    &#x2F;&#x2F; 最终输出结果为倒序    for(int i &#x3D; 0; i &lt; cnt; ++i)&#123;        cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>核心代码：</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int u)&#123;    for(int p &#x3D; head[u]; p; p &#x3D; edges[p].nxt)&#123;        if(!edges[p].vis)&#123;            edges[p].vis &#x3D; 1;            dfs(edges[p].v);            path.push(edges[p].word);        &#125;    &#125;&#125;int main()&#123;    input();    &#x2F;&#x2F; 读入单词，并进行建图，由于要求字典序最小，因此需要进行排序，参考上文 图的遍历 一题    int flag &#x3D; -1;    &#x2F;&#x2F; 找到起点 flag    for(int i &#x3D; 0; i &lt; maxgroup; ++i)&#123;        &#x2F;&#x2F; degree[i][0] 表示出读，degree[i][1] 表示入度        if(degree[i][0] &#x3D;&#x3D; degree[i][1]+1)&#123;            flag &#x3D; i;            break;        &#125;    &#125;    if(flag &#x3D;&#x3D; -1)&#123;        &#x2F;&#x2F; 如果找不到起点，说明此时存在欧拉回路，只需找到字典序最小的单词即可        for(int i &#x3D; 0; i &lt; maxgroup; ++i)&#123;            if(words[i].size())&#123;                dfs(i);                break;            &#125;        &#125;    &#125;    else dfs(flag); &#x2F;&#x2F; 从起点开始 dfs    output();    system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1363-幻象迷宫（dfs思维题）"><a href="#P1363-幻象迷宫（dfs思维题）" class="headerlink" title="P1363_幻象迷宫（dfs思维题）"></a>P1363_幻象迷宫（dfs思维题）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1363">题目链接</a></p></li><li><p>题目描述：给定一个n*m的矩阵迷宫，其中“#”表示墙，“.”表示道路，将该迷宫上下左右进行平移，可以平铺成一个无限大的迷宫。给定起点，问能否从起点出发到达无限远的位置。</p></li><li><p>解题思路：进行dfs搜索，记录走到的位置的<strong>绝对位置</strong>（lx, ly)（绝对位置是指其在无限大迷宫中相对起点的横纵坐标，也就是说lx,ly不对边长进行取模运算），同时该所走到的位置还有一个<strong>朴素位置</strong>（x，y）（朴素位置是指其在原始迷宫中相对起点的位置，x,y需进行取模运算）。当走到某个位置时，若之前已经走到过该位置，且两次的绝对位置不同，则可以在迷宫中可以走到无限远的地方。</p></li><li><p>核心代码：</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; x，y表示朴素位置，lx，ly表示绝对位置&#x2F;&#x2F; g[x][y][0] 记录该点是否已访问以及能否访问，-1 表示该点为墙，0 表示未访问，1 表示已被访问过&#x2F;&#x2F; g[x][y][1] 和 g[x][y][2] 分别记录绝对位置的横纵坐标bool dfs(int x, int y, int lx, int ly)&#123;    bool flag &#x3D; false;    if(g[x][y][0]&#x3D;&#x3D;1 &amp;&amp; (g[x][y][1]!&#x3D;lx || g[x][y][2]!&#x3D;ly))&#123;        &#x2F;&#x2F; 当前位置之前已经访问过，且两者的绝对位置不同        flag &#x3D; true;    &#125;else if(g[x][y][0]&#x3D;&#x3D;0)&#123;        &#x2F;&#x2F; 进行标记记录绝对位置        g[x][y][0] &#x3D; 1;        g[x][y][1] &#x3D; lx;        g[x][y][2] &#x3D; ly;        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;            int xx &#x3D; (x + d[i].x + n)%n;            int yy &#x3D; (y + d[i].y + m)%m;            flag &#x3D; dfs(xx, yy, lx+d[i].x, ly+d[i].y);            if(flag) break;        &#125;    &#125;    return flag;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1347-排序（拓扑排序确定有序序列）"><a href="#P1347-排序（拓扑排序确定有序序列）" class="headerlink" title="P1347_排序（拓扑排序确定有序序列）"></a>P1347_排序（拓扑排序确定有序序列）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1347">题目链接</a></p></li><li><p>题目描述：有一串字母，两两之间满足大小关系，现给定 n 个字母，m 条关系，每条关系以 “A &lt; B” 的形式依次给出，若根据前 x 条关系可以确定这 n 个字母唯一的顺序关系，则输出结果，若根据前 x 条关系发现这 n 个字母之间无法形成顺序关系，同样输出结果，若直到最后也无法确定其是否能够组成固定的顺序关系，则输出另一结果。</p></li><li><p>解题思路：这道题是一道典型的拓扑排序题目，每读入一个关系，就根据当前所建图执行一遍拓扑排序，其有三种结果：发现当前图成环、发现可以确定唯一的顺序关系、发现无法确定唯一的顺序关系。前两种结果直接输出，停止程序，而若是第三种结果则继续读入，重复拓扑排序的步骤。</p></li><li><p>核心代码：</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int topo()&#123;    queue&lt;int&gt; q;    int flag &#x3D; 0, degree[maxn], cnt &#x3D; 0;    &#x2F;&#x2F; 复制一遍顶点入度    for(int i &#x3D; 0; i &lt; n; ++i)&#123;        degree[i] &#x3D; indegree[i];    &#125;    &#x2F;&#x2F; 将所有入度为 0 的点加入队列    for(int i &#x3D; 0; i &lt; n; ++i)&#123;        if(!degree[i])&#123;            q.push(i);        &#125;    &#125;    &#x2F;&#x2F; 开始拓扑排序    int p;    while(!q.empty())&#123;        &#x2F;&#x2F; 当队列中存在不止一个元素时，说明此时存在不稳定的队列或者当前的边未包括全部的顶点        if(q.size() &gt; 1) flag &#x3D; 1;        p &#x3D; q.front(); q.pop();        ans[cnt++] &#x3D; p; &#x2F;&#x2F; 记录当前确定的顺序，该顺序可能唯一，也可能不唯一        for(int k &#x3D; head[p]; k; k &#x3D; edges[k].nxt)&#123;            int pp &#x3D; edges[k].to;            --degree[pp];            if(!degree[pp]) q.push(pp);        &#125;    &#125;    &#x2F;&#x2F; 通过检查是否有入度不为0来确定是否存在环    int status &#x3D; 0;     &#x2F;&#x2F; 默认既没有环，也没有稳定序列    for(int i &#x3D; 0; i &lt; n; ++i)&#123;        if(degree[i])&#123;            status &#x3D; 1; &#x2F;&#x2F; 标记存在环            break;        &#125;    &#125;    if(!flag &amp;&amp; !status &amp;&amp; cnt &#x3D;&#x3D; n) status &#x3D; 2;   &#x2F;&#x2F; 此时存在稳定序列    return status;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1983-车站分级（有向无环图不固定起点和终点最长路径）"><a href="#P1983-车站分级（有向无环图不固定起点和终点最长路径）" class="headerlink" title="P1983_车站分级（有向无环图不固定起点和终点最长路径）"></a>P1983_车站分级（有向无环图不固定起点和终点最长路径）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1983">题目链接</a></p></li><li><p>题目描述：有编号从 1 到 n 的火车站，不同的站点有不同的登记。火车会在其经过的某些火车站停下，如果火车站在序列为{$a_1,a_2,a_3,…,a_k$}的车站中停下，则从首发站 $a_1$ 到终点站 $a_k$ 中的所有<strong>没有停下的车站</strong>的级别都低于停下的车站{$a_1,a_2,a_3,…,a_k$}。现给出 m 个火车的航站表（每个表中包含了第 i 趟火车所有停下的车站），试确定所划分级别的最小数目。</p></li><li><p>解题思路：首先根据航站表建图，根据已确定的等级关系所建的图找出图中最长路径即可。详情见题目<a href="P1113_杂务（dfs查找固定终点的最长路径）">杂务</a>。本题的一个小难点在于如何根据航展表建图，建图部分代码如下：</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; bool vis[maxn] 记录停下的站点&#x2F;&#x2F; bool g[maxn][maxn] 记录已经加的边void input()&#123;    n &#x3D; read(); m &#x3D; read();    int port[maxn]; &#x2F;&#x2F; 记录停下的站点    for(int i &#x3D; 0; i &lt; m; ++i)&#123;        int k, l, r;        k &#x3D; read();        memset(vis, 0, sizeof(vis));        for(int j &#x3D; 0; j &lt; k; ++j)&#123;            port[j] &#x3D; read();   &#x2F;&#x2F; 以两种方式存储停下的站点            vis[port[j]] &#x3D; 1;        &#125;        l &#x3D; port[0]; r &#x3D; port[k-1]; &#x2F;&#x2F; 得到始发站和终点站        for(int p &#x3D; l; p &lt; r; ++p)&#123; &#x2F;&#x2F; 遍历是发展到终点站之间的所有站点            if(!vis[p])&#123;    &#x2F;&#x2F; 如果该站点未被停下，则为该站点和停下的站点建边                for(int j &#x3D; 0; j &lt; k; ++j)&#123;                    if(!g[port[j]][p])&#123; &#x2F;&#x2F; 若该边已经加过，则不再添加                        edges[port[j]].push_back(p);                        g[port[j]][p] &#x3D; true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数学问题小结</title>
      <link href="2020/12/18/ji-chu-shu-xue-wen-ti-xiao-jie/"/>
      <url>2020/12/18/ji-chu-shu-xue-wen-ti-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="基础数学问题总结"><a href="#基础数学问题总结" class="headerlink" title="基础数学问题总结"></a>基础数学问题总结</h1><blockquote><p>基础数学问题主要涉及到进制的转换、位运算、计数原理与排列组合和整除理论。注：本题解中代码未必为 AC 代码, 因为其为了配合题目知识点的理解进行了一部分简化。</p></blockquote><h2 id="进制的转换以及位运算"><a href="#进制的转换以及位运算" class="headerlink" title="进制的转换以及位运算"></a>进制的转换以及位运算</h2><blockquote><p>进制的转换要求能够熟练的进行不同进制之间的转换，二进制、八进制、十六进制和十进制都是非常常见的进制表达形式。</p></blockquote><ul><li><p><strong>题目1</strong> <a href="https://www.luogu.com.cn/problem/P1143">P1143 进制转换</a></p><ul><li>题目描述：给出一个进制为 $n$ 的数 $x$，要求将其转化为进制为 $m$ 的数。</li><li>解题思路：先将 $x$ 转化为十进制数, 再将该十进制数转化为 $m$ 进制数。</li></ul></li><li><p><strong>题目2</strong> <a href="https://www.luogu.com.cn/problem/P1017">P1017 进制转换</a></p><ul><li>题目描述：读入一个十进制数和一个负进制数的基数, 输出此负进制数</li><li>背景知识：考虑 $a \% b$, 当 $a$ 和 $b$ 不一定为正数时, 其结果正负号与 $a$ 的符号保持一致。且取余结果试图使得其结果的绝对值尽可能的小。如果我们总是想要得到正数的结果, 那么当结果为负时, 我们为结果加 $abs(b)$ 即可。设所求<strong>正余数</strong>为 $a_0$, 其满足$a = b * k + a_0$。</li><li>解题思路：考虑十进制转换为 m 进制： $x_{10} = a_0 + a_1m^1 + a_2m^2 + … + a_km^k$, 其中 $m$ 都为正数, 那么对于负进制转换, 只需考虑到其中的 $m$ 都为负数即可, 此时就会遇到<strong>负数求模</strong>的情况。由于 $a_0, a_1, …, a_k$ 需要全部为正数, 因此我们只需利用上边的背景知识求解即可。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(a)&#123;    &#x2F;&#x2F; 考虑求余结果的正负性    if(a&lt;0 &amp;&amp; a%b) c &#x3D; a%b + abs(b);    else c &#x3D; a%b;    a &#x3D; (a-c)&#x2F;b;    s.push(c);&#125;while(!s.empty()) &#123;cout&lt;&lt;s.top();s.pop();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目3</strong> <a href="https://www.luogu.com.cn/problem/P1469">P1469 找筷子</a></p><ul><li>题目描述：给出若干数, 除其中的某一个数外, 其他的数都两两出现, 试找出唯一不重的那个数。</li><li><p>解题思路：异或所有的数, 最后得到的数即为唯一不重的数。我们可以将所有重复的数字两两配对并放在最前边, 将他们进行异或, 最后可以得到 0, 再拿 0  与唯一不重复的那个数 $x$ 进行异或, 最后得到 $x$ 本身。原理如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 异或运算满足交换律和结合律&#x2F;&#x2F; 且x ^ x &#x3D; 0 0 ^ x &#x3D; x&#x2F;&#x2F; 所以a ^ b ^ c ^ d ^ c ^ a ^ b &#x3D; (a ^ a) ^ (b ^ b) ^ (c ^ c) ^ d&#x3D;0 ^ 0 ^ 0 ^ d &#x3D; d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; read()为自定义的快读函数for(int i &#x3D; 0; i &lt; n; ++i)    a ^&#x3D; (b&#x3D;read());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目4</strong> <a href="https://www.luogu.com.cn/problem/P1100">P1100 高低位交换</a></p><ul><li>题目描述：给定一个小于 $2^{32}$ 的正整数, 其在计算机中通过 32 位二进制数的形式存储, 交换其前 16 位二进制数和其后的 16 位二进制数, 得到一个新的正整数, 试求出该正整数。</li><li>题目思路：我们只需要得到其前 16 位和后 16 位, 然后将其交换位置并合在一起即可。思路有很多, 给出一种体位运算特性较多的思路。假设原数字为 x 我们可以通过 <code>x &amp; 0xffff0000</code> 来得到前 16 位数字, 通过 <code>x &amp; 0x0000ffff</code> 来得到后 16 位数字, 通过移位运算调整两者的位置, 最后将两者相“<strong>或</strong>”, 从而得到答案</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 注意无符号整数才包含 2^32 内的正整数unsigned int x;cin&gt;&gt;x;&#x2F;&#x2F; 两个移位运算分别是将前 16 位二进制数放在后 16 位的位置上&#x2F;&#x2F; 和将后 16 位二进制数放在前 16 位上cout&lt;&lt;(((x &amp; 0xffff0000) &gt;&gt; 16) | ((x &amp; 0x0000ffff) &lt;&lt; 16)))&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计数原理与排列组合"><a href="#计数原理与排列组合" class="headerlink" title="计数原理与排列组合"></a>计数原理与排列组合</h2></li></ul></li><li><p><strong>题目1</strong> <a href="https://www.luogu.com.cn/problem/P1866">P1866 编号</a></p><ul><li>题目描述：给定 $n$ 个位置, 在每个位置中放置一个数字, 每个位置 $i$ 所允许的数字范围为 $1 \rightarrow maxNumber[i]$, 且每个位置所放数字不能相同, 试确定有几种放置情况。</li><li>题目思路：首先读取数组 $maxNumber[i]$, 随后将 $maxNumber[i]$ 从小到大进行排序, 随后依次分配数字即可。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 0; i &lt; n; ++i) cin&gt;&gt;a[i];&#x2F;&#x2F; 对数组进行排序, 排序之后位置 i 之前分配的数字必然被包含在 a[i] 中sort(a, a+n);&#x2F;&#x2F; 使用 b 来存储当前已经有多少个数字被分配过了long long ans &#x3D; 1, b &#x3D; 0;for(int i &#x3D; 0; i &lt; n; ++i)&#123;    &#x2F;&#x2F; a[i] - b 表示当前位置所能摆放的数字个数    if(a[i] - b &lt;&#x3D; 0)&#123;        ans &#x3D; 0;        break;    &#125;else&#123;        ans *&#x3D; (a[i] - b);        ans %&#x3D; MOD;        ++b;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目2</strong> <a href="https://www.luogu.com.cn/problem/P2822">P2822 组合数问题</a></p><ul><li>题目描述：给出 $n$、$m$, 试求有多少对 $(i, j)$ 满足 $\{(i, j) | 0 \leq i \leq n, 0 \leq j \leq min(i, m), k | C_i^j\}$。<code>a | b</code> 表示 $b mod a == 0$。题目有多组数据, 每一组数据都会提供一个新的 $n, m$, 但是 $k$ 保持不变。</li><li><p>背景知识：杨辉三角打表。朴素的组合数求法是利用公式 $C_i^j = \frac{i!}{j!(i-j)!}$, 但是当我们需要用到大量的组合数时, 我们一一求解是不显示的, 因此需要对组合数提前进行打表。组合数有一个<strong>臭蛋公式</strong>：$C_i^j = C_{i-1}^j + C_{i-1}^{j-1}$, 使用该公式进行递推打表, 可以得到杨辉三角, 也即组合数表。代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; a[i][j] 表示 i 个物体中挑选 j 个物体的组合数void init(void)&#123;    for(int i &#x3D; 1; i &lt; maxn; ++i)&#123;        for(int j &#x3D; 0; j &lt;&#x3D; i; ++j)&#123;            if(j&#x3D;&#x3D;0 || j&#x3D;&#x3D;i) a[i][j] &#x3D; 1;            else a[i][j] &#x3D; a[i-1][j-1] + a[i-1][j];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>题目思路：使用<strong>打表 + 前缀和</strong>的方法。首先对杨辉三角进行打表, 随后由于 $k$ 值固定, 我们预先对所有的 $(i, j)$ 是否满足题目条件进行判定, 并使用数组 $b[maxn][maxn]$ 存储判定结果, $b[p][q]$ 表示所有满足 $i \leq p, j \leq q, k | C_i^j$ 的 $(i, j)$ 对儿的个数。那么对于每次查询可以使用 $O(1)$ 的时间复杂度解决问题。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void init(int k)&#123;    &#x2F;&#x2F; 模拟杨辉三角打表    for(int i &#x3D; 1; i &lt; maxn; ++i)&#123;        for(int j &#x3D; 0; j &lt;&#x3D; i; ++j)&#123;            if(j&#x3D;&#x3D;0 || j&#x3D;&#x3D;i) a[i][j] &#x3D; 1;            else a[i][j] &#x3D; a[i-1][j-1] + a[i-1][j];            &#x2F;&#x2F; 存储 a[i][j] 对 k 求余的结果            a[i][j] %&#x3D; k;        &#125;    &#125;    &#x2F;&#x2F; 得到前缀和数组    for(int i &#x3D; 1; i &lt; maxn; ++i)&#123;        for(int j &#x3D; 1; j &lt;&#x3D; i; ++j)&#123;            &#x2F;&#x2F; 三角形的前缀和递推公式            ans[i][j] &#x3D; ans[i][j-1] + ans[i-1][j] - ans[i-1][j-1];            if(!a[i][j]) ++ans[i][j];        &#125;        &#x2F;&#x2F; 由于边界条件的存在, 这条语句一定要有        ans[i][i+1] &#x3D; ans[i][i];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目3</strong> <a href="https://www.luogu.com.cn/problem/P2789">P2789 直线交点数</a></p><ul><li>题目描述：平面上有N条直线，且无三线共点，那么这些直线能有多少<strong>种</strong>不同的交点数？</li><li>题目思路：求出所有的相交情况, 求出每种相交情况的交点个数, 由于不同的相交情况可能有相同的交点数, 因此需要对交点数进行标记, 防止重复统计, 最后统计被标记的交点个数。使用动态规划思想考虑相交情况, 假设目前有 $n$ 条线, 该 $n$ 条线中有 $i$ 条直线平行, 而其余的直线与该 $i$ 条直线相交, 令 $dp[n]$ 表示 $n$ 条直线的情况, 则有 $dp[n] = \sum_{i=1}^{n}(i*(n-i)+dp[n-i])$</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 第一个参数表示有 n 条直线的状态&#x2F;&#x2F; 第二个参数表示此时的交点数目void dp(int n, int m)&#123;    if(!p &amp;&amp; !vis[m]) ++ans, vis[m] &#x3D; 1;    &#x2F;&#x2F; 对交点数进行标记    else&#123;        &#x2F;&#x2F; 枚举平行线的数量        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;            dp(n-i, m + i*(n-i));        &#125;    &#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目四</strong> <a href="https://www.luogu.com.cn/problem/P3913">P3913 车的攻击</a></p><ul><li>题目描述：$N\times N$ 的国际象棋棋盘上有 $K$ 个车, 给出 $K$ 个车的位置, 求至少被一个车攻击的格子数目。(车可以攻击同一行或同一列的格子)</li><li>题目思路：将棋盘上的车投影到第一行和第一列中, 假设投影之后第一行有 $a$ 个车, 第一列有 $b$ 个车, 被攻击的格子数有 $a\times N + b\times N - a\times b$。说起投影, 第一反应是使用一个 $vis$ 数组, 但是本体 $N$ 的数据范围为 1e9, 因此会 MLE。我采用的是哈希表解决该问题, 使用 STL 中的 sort 和 unique()(去重函数) 也可以解决该问题</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 采用哈希表的方式进行投影&#x2F;&#x2F; num 表示在第一行(列)上车的投影个数&#x2F;&#x2F; 一列(行)中可能有多个车, 投影的目的就是排除这些重复的车void insert(int n, int *a, long long &amp;num)&#123;    int i &#x3D; n%maxn;    if(!a[i]) a[i] &#x3D; n, ++num;    else&#123;        while(a[i] !&#x3D; n &amp;&amp; a[i]) i &#x3D; (i+1)%maxn;        if(!a[i]) a[i] &#x3D; n, ++num;    &#125;&#125;int main()&#123;    int n, k, a, b;    long long p &#x3D; 0, q &#x3D; 0;    n&#x3D;read(); k&#x3D;read();    for(int i &#x3D; 0; i &lt; k; ++i)&#123;        a &#x3D; read(); b &#x3D; read();        &#x2F;&#x2F; 分别向第一行插入位置信息, 向第一列插入位置信息        insert(a, row, p); insert(b, col, q);    &#125;    cout&lt;&lt;p*n+q*n-p*q&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目5</strong> <a href="https://www.luogu.com.cn/problem/P2638">P2638 安全系统</a></p><ul><li>题目描述：有 $n$ 个连续存储区, 每一个存储区可以存储任意个数的 0 或 1, 现给出 $a$ 个 0, 以及 $b$ 个 1, 将其存储在存储区中(无需使用全部的 0 和 1), 问有多少种存储方式。</li><li>题目思路：我们可以发现存储 0 和存储 1 之间并不相关。因此我们只需分别枚举存储 0 的情况和存储 1 的情况, 然后将其相乘即可。首先考虑如何存储 0, 将 $i$ 个 0 平均分到 $n$ 个区域中, 且允许区域为空, 我们可以使用升级版的<strong>插板法</strong>, 可以求得有 $C_{a+n-1}^{n-1}$ 种情况。分配 1 的情况同理。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">generate(max(a+n, b+n));    &#x2F;&#x2F; 对组合数进行打表for(int i &#x3D; 0; i &lt;&#x3D; a; ++i)&#123;&#x2F;&#x2F; 枚举放入多少个 0    for(int j &#x3D; 0; j &lt;&#x3D; b; ++j)&#123;    &#x2F;&#x2F; 枚举放入多少个 1        ans +&#x3D; 1ull* c[i-1+n][n-1] * c[j-1+n][n-1]; &#x2F;&#x2F; 将两者的情况数相乘    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目6</strong> <a href="https://www.luogu.com.cn/problem/P1246">1246 编码</a></p><ul><li>题目描述：有 26 个字母, 将其组合成特殊的单词, 这些单词中的字母按照严格升序的顺序进行严格排序, 得到$a,b,…,z,ab,ac,…,az,…,yz,…abc,…$ 的一系列单词, 将这些单词按照其在序列中的顺序从 1 开始进行编号。现给定一个特殊单词, 求出它的编号。</li><li>解题思路：这道题是使用一个巧妙的组合思想来求解的。假设给定单词为 $dgz$, 我们只需求出其前边有几个单词再加 1 即可。该单词有 3 位, 我们先找出 2 位的单词和 1 位的单词有多少个, 对于 2 位的单词, 我们知道其不会有重复的, 并且其固定按照升序排序, 因此可以转换成在 26 个字母中挑出 2 个字母的问题, 其值为 $C_{26}^2$, 1 位数的单词同理, 接下来我们只需考虑在其之前三位数的单词的个数即可。我们可以接着考虑以 $a、b、c$ 开头的三位数单词的个数, 随后考虑以 $de、df$ 开头的单词的个数, 依次类推。最后将所有单词加起来再加一就是目标单词的编号。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 用于得到组合数, 此处非打表LL c(LL n, LL m)&#123;    if(!m) return 1;    LL num &#x3D; 1;    for(LL i &#x3D; n; i &gt; n-m; --i)&#123;        num *&#x3D; i;    &#125;    for(LL i &#x3D; m; i &gt; 0; --i)&#123;        num &#x2F;&#x3D; i;    &#125;    return num;&#125;&#x2F;&#x2F; 用于得到所有位数小于目标单词的单词的数目for(int i &#x3D; 1; i &lt; len; ++i)&#123;    ans +&#x3D; c(letter, i);&#125;&#x2F;&#x2F; 用于得到位数与目标单词位数相同, 且位置在其之前的单词的个数int last &#x3D; 0;for(int i &#x3D; 0; i &lt; len; ++i)&#123;    for(int j &#x3D; last+1; j &lt;&#x3D; str[i]-&#39;a&#39;; ++j)&#123;        ans +&#x3D; c(letter-j, len-i-1);    &#125;    last &#x3D; str[i]-&#39;a&#39;+1;&#125;cout&lt;&lt;ans+1&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="整除理论"><a href="#整除理论" class="headerlink" title="整除理论"></a>整除理论</h2></li></ul></li><li><p><strong>题目1</strong> <a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></p><ul><li>题目描述：给出 $q$ 个查询, 每次要求输出第 $k_i$ 小的素数</li><li>解题思路：欧拉筛、埃氏筛都可以使用</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 埃氏筛思想：从小到大逐个得到小于 n 的质数&#x2F;&#x2F; 每得到一个质数，就将 n 以内该质数的所有倍数筛去int Eratosthenes(int n, int *pri)&#123;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i])&#123;    &#x2F;&#x2F; 满足该条件说明 i 为质数            pri[cnt++] &#x3D; i;            &#x2F;&#x2F; 筛去所有质数的倍数            &#x2F;&#x2F; 对于 k * i，当 k &lt; i 时该数已经被 k 筛去            &#x2F;&#x2F; 故 k 从 i 开始            for(long long j &#x3D; i * i * 1ll; j &lt;&#x3D; n; j +&#x3D; i)                vis[j] &#x3D; 1;        &#125;&#125;&#x2F;&#x2F; 欧拉筛思想：枚举从 1 到 n 的所有数 i&#x2F;&#x2F; 使 i 乘上所有已求得的质数筛去合数&#x2F;&#x2F; 通过最小因子的思想进行线性优化，即每一个数都被其最小因子筛掉，而不是被其他因子筛掉int Euler(int n, int *pri)&#123;    for(int i &#x3D;2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i]) pri[cnt++] &#x3D; i; &#x2F;&#x2F; 满足该条件说明 i 为质数        for(int j &#x3D; 0; j &lt; cnt; ++j)&#123;            if(1ll * pri[j] * i &gt; n) break;            vis[i * pri[j]] &#x3D; 1;            &#x2F;&#x2F; 下面的代码是优化的核心            &#x2F;&#x2F; 对于 i * pri[j]，若 i % pri[j] &#x3D;&#x3D; 0            &#x2F;&#x2F; 则 i &#x3D; pri[j] * n&#39;            &#x2F;&#x2F; 那么对于 i * pri[k]，k &gt; j            &#x2F;&#x2F; i * pri[k] &#x3D; pri[j] * n&#39; * pri[k] &#x3D; pri[j] * (n&#39; * pri[k])            &#x2F;&#x2F; 其中 pri[j] 是 i * pri[k] 的最小因子            &#x2F;&#x2F; 数 i * pri[k] 在之后会通过 pri[j] * (n&#39; * pri[k]) 筛掉，无需在此处筛去            if(i % pri[j] &#x3D;&#x3D; 0) break;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="2020/12/18/ou-la-han-shu/"/>
      <url>2020/12/18/ou-la-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>[TOC]</p><blockquote><p>本来好好的刷着排列组合的题目鬼知道怎么蹦出来了一个欧拉函数的题，以前也没有接触过，那就只能学一学喽</p></blockquote><p><strong>整理自<a href="https://oi-wiki.org/math/euler/">oi-wiki-欧拉函数</a></strong></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>当需要求取多个数的欧拉函数时，需要借助<strong>埃氏筛</strong>和<strong>欧拉筛</strong>的相关思想。</p><h3 id="埃氏筛-Eratosthenes"><a href="#埃氏筛-Eratosthenes" class="headerlink" title="埃氏筛(Eratosthenes)"></a>埃氏筛(Eratosthenes)</h3><p>时间复杂度为 $O(nlglgn)$，<del>我不会证QAQ</del></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 埃氏筛思想：从小到大逐个得到小于 n 的质数&#x2F;&#x2F; 每得到一个质数，就将 n 以内该质数的所有倍数筛去int Eratosthenes(int n, int *pri)&#123;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i])&#123;    &#x2F;&#x2F; 满足该条件说明 i 为质数            pri[cnt++] &#x3D; i;            &#x2F;&#x2F; 筛去所有质数的倍数            &#x2F;&#x2F; 对于 k * i，当 k &lt; i 时该数已经被 k 筛去            &#x2F;&#x2F; 故 k 从 i 开始            for(long long j &#x3D; i * i * 1ll; j &lt;&#x3D; n; j +&#x3D; i)                vis[j] &#x3D; 1;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><p>时间复杂度为 $O(n)$，每一个数仅被访问一次</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 欧拉筛思想：枚举从 1 到 n 的所有数 i&#x2F;&#x2F; 使 i 乘上所有已求得的质数筛去合数&#x2F;&#x2F; 通过最小因子的思想进行线性优化，即每一个数都被其最小因子筛掉，而不是被其他因子筛掉int Euler(int n, int *pri)&#123;    for(int i &#x3D;2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i]) pri[cnt++] &#x3D; i; &#x2F;&#x2F; 满足该条件说明 i 为质数        for(int j &#x3D; 0; j &lt; cnt; ++j)&#123;            if(1ll * pri[j] * i &gt; n) break;            vis[i * pri[j]] &#x3D; 1;            &#x2F;&#x2F; 下面的代码是优化的核心            &#x2F;&#x2F; 对于 i * pri[j]，若 i % pri[j] &#x3D;&#x3D; 0            &#x2F;&#x2F; 则 i &#x3D; pri[j] * n&#39;            &#x2F;&#x2F; 那么对于 i * pri[k]，k &gt; j            &#x2F;&#x2F; i * pri[k] &#x3D; pri[j] * n&#39; * pri[k] &#x3D; pri[j] * (n&#39; * pri[k])            &#x2F;&#x2F; 其中 pri[j] 是 i * pri[k] 的最小因子            &#x2F;&#x2F; 数 i * pri[k] 在之后会通过 pri[j] * (n&#39; * pri[k]) 筛掉，无需在此处筛去            if(i % pri[j] &#x3D;&#x3D; 0) break;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="欧拉函数-Euler’s-totient-function-的定义"><a href="#欧拉函数-Euler’s-totient-function-的定义" class="headerlink" title="欧拉函数(Euler’s totient function)的定义"></a>欧拉函数(Euler’s totient function)的定义</h2><p>使用 $\phi(x)$ 来代表欧拉函数，其表示的是小于等于 $x$ 和 $x$ 互质的数的个数。根据定义我们可以知道 $\phi(1) = 1$，当 $p$ 为质数时 $\phi(p) = p-1$。注意，1 与任何数都互质。</p><h2 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h2><ul><li>欧拉函数是积性函数<br>  欧拉函数为积性函数是指当 $a$, $b$ 两个数互质时，即 $gcd(a, b) = 1$，$\phi(a \times b)= \phi(a) \times \phi(b)$<br>  特别的，当 $n$ 为奇数时，$\phi(2n) = \phi(n)$</li><li>$n = \sum_{d|n}\phi(d)$<br>  上述公式可以解释为所有 $n$ 的因数的欧拉函数的和为 $n$ 本身。可以使用<a href="https://oi-wiki.org/math/mobius/">莫比乌斯反演</a>来证明，然而我不会。此处使用其他方法证明。<br>  <strong>条件一</strong>：如果 $gcd(k, n) = d$，即 $k$ 与 $n$ 的最大公因数为 $d$，那么当 $k$ 与 $n$ 同时除以 $d$ 时（$k$ 和 $n$ 一定可以整除 $d$），$\frac{k}{d}$ 与 $\frac{n}{d}$ 互质。有 $gcd(\frac{k}{d},\frac{n}{d}) = 1$<br>  <strong>条件二</strong>：如果令 $f(x)$ 表示满足 $gcd(k, n) = x$ 的 $k$ 的个数，即 $f(x)$ 为所有小于等于 $n$ 的数中和 $n$ 的最大公倍数为 $x$ 的数的个数，那么有<script type="math/tex">n = f(1) + f(2) + f(3) + ... + f(n) = \sum_{i=1}^{n}f(i)</script>其原因在于，对于任意从 1 到 $n$ 之间的数字 $m$，$m$ 只可能与 $n$ 有唯一的一个最大公因数 $i$，且 $i \leq n$，那么我们只需枚举从 1 到 $n$ 中所有的数字 $i$ 作为最大公因数，并累加 $f(i)$，其就代表枚举了 $m$ 从 1 到 $n$ 的所有情况，故 $\sum_{i=1}^n f(x) = n$<br>  &emsp;<br>  根据上述两个条件，我们可以找到 $f(x)$ 定义的等价形式，即$f(x)$ 表示满足 $gcd(\frac{k}{x}, \frac{n}{x}) = 1$ 的 $k$ 的个数，把 $\frac{k}{x}$ 看做 $k$，则 $f(x)$ 表示满足 $gcd(k, \frac{n}{x}) = 1$ 的 $k$ 的个数，根据欧拉函数的定义，可以发现 $f(x) = \phi(\frac{n}{x})$。<br>  这时有 $n = \sum_{i=1}^{n}f(i) = \sum_{i=1}^{n}\phi(\frac{n}{i}) =\sum_{d|n}\phi(d))$。</li><li>若 $n = p^k$，且 $p$ 为质数，那么 $\phi(n) = p^k-p^{k-1}$。原因是从 1 到 $n$ 中所有与 $n$ 不互质的数的个数有 $n/p = n^p/p = p^{k-1}$ 个，故与 $n$ 互质的数的个数有 $n-p^{k-1}=p^k-p^{k-1}$ 个。</li><li>由唯一分解定理，设 $n=\prod_{i=1}^n{p_i^{k_i}}$，由于 $\phi(n)$ 为积性函数，故</li></ul><script type="math/tex; mode=display">\begin{aligned}phi(n) =& \prod_{i=1}^n\phi(p_i^{k_i})\\=& \prod_{i=1}^n(p^k-p^{k-1})\\=& \prod_{i=1}^np_i^k(1-\frac{1}{p_i})\\=& \prod_{i=1}^np_i^k\times\prod_{i=1}^n(1-\frac{1}{p_i})\\=& n\times\prod_{i=1}^n(1-\frac{1}{p_i})\end{aligned}</script><p>我们可以得到欧拉函数的对应公式：</p><script type="math/tex; mode=display">\phi(n) = n \times \prod_{i=1}^n(1-\frac{1}{p_i})</script><h2 id="求出单个欧拉函数的值"><a href="#求出单个欧拉函数的值" class="headerlink" title="求出单个欧拉函数的值"></a>求出单个欧拉函数的值</h2><p>我们可以简单的根据上述欧拉公式来求得单个欧拉函数的值：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int euler_phi(int x)&#123;    int ans &#x3D; n;    for(int i &#x3D; 2; i * i &lt;&#x3D; n; ++i)&#123;        if(n % i &#x3D;&#x3D; 0)&#123;            ans &#x3D; ans &#x2F; i * (i - 1);            whiel(n % i &#x3D;&#x3D; 0) n &#x2F;&#x3D; i;        &#125;    &#125;    &#x2F;&#x2F; 特判 n 为质数的情况    if(n &gt; 1) ans &#x3D; ans &#x2F; n * (n-1);    return n;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法可以使用 <a href="https://oi-wiki.org/math/pollard-rho/">Pollard Rho</a>进行优化，然而菜鸡的我现在貌似还用不到。</p><h2 id="求出多个欧拉函数的值"><a href="#求出多个欧拉函数的值" class="headerlink" title="求出多个欧拉函数的值"></a>求出多个欧拉函数的值</h2><p>借助上述的公式，我们可以借用埃氏筛的思想求欧拉函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void phi_table(int n, int *phi)&#123;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i) phi[i] &#x3D; 0;    phi[1] &#x3D; 1;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)        if(!phi[i])&#123;            for(int j &#x3D; i; j &lt;&#x3D; n; j +&#x3D; i)&#123;                if(!phi[j]) phi[j] &#x3D; j;                phi[j] &#x3D; phi[j] &#x2F; i * (i - 1);            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过欧拉筛来线性求解多个欧拉函数的值。首先需要进行公式推导:</p><p>在欧拉筛的过程中，每一个合数都是被其最小因数筛掉的，我们设该最小因数为 $p_1$，剩余部分为 $n’$，两者满足关系 $p_1*n’=n$。<br>考虑 $n’$ 的两种情况，如果 $n’ \bmod p_1 = 0$，则 $n’$ 包含了 $n$ 的全部质因子。</p><script type="math/tex; mode=display">\begin{aligned}\phi(n) =& n \times \prod_{i=1}^n{\frac{p_i-1}{p_i}}\\=&p_1\times n' \times \prod_{i=1}^n{\frac{p_i-1}{p_i}}\\=&p_1\times \phi(n')\end{aligned}</script><p>如果 $n’ \bmod p_1 \neq 0$，则 $p_1$ 和 $n’$ 互质，根据欧拉函数的性质有</p><script type="math/tex; mode=display">\begin{aligned}\phi(n) =& \phi(n') \times \phi(p_1)\\=& \phi(n') \times (p_1 - 1)\end{aligned}</script><p>据此，我们可以在通过欧拉筛得到质数的同时得到欧拉函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int euler(int n, int* phi, int* pri)&#123;    phi[1] &#x3D; 1;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i])&#123;            &#x2F;&#x2F; 对于质数直接进行标记            phi[i] &#x3D; i - 1;            pri[cnt++] &#x3D; i;            vis[i] &#x3D; 1;        &#125;        for(int j &#x3D; 0; j &lt; cnt; ++j)&#123;            if(1ll * pri[j] * i &gt; n) break;            vis[i * pri[j]] &#x3D; 1;            if(i % pri[j])&#123;                &#x2F;&#x2F; 对应第二种情况                phi[i * pri[j]] &#x3D; phi[i] * (pri[j] - 1);            &#125;else&#123;                &#x2F;&#x2F; 对应第一种情况                phi[i * pri[j]] &#x3D; phi[i] * pri[j];                break;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/18/hello-world/"/>
      <url>2020/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
